[
  {
    "title": "Next.js App Router 完全指南",
    "excerpt": "全面介绍 Next.js 14 的 App Router，包括路由系统、布局、加载状态、错误处理等核心概念和最佳实践。",
    "publishedAt": "2024-02-01T00:00:00.000Z",
    "author": "li-lingfeng",
    "category": "frontend",
    "tags": [
      "nextjs",
      "react",
      "typescript"
    ],
    "featured": true,
    "published": true,
    "image": "/images/articles/nextjs-app-router.jpg",
    "seoTitle": "Next.js App Router 完全指南 - 掌握新一代路由系统",
    "seoDescription": "学习 Next.js 14 App Router 的核心概念和最佳实践，包括文件系统路由、布局、服务器组件等",
    "seoKeywords": [
      "Next.js",
      "App Router",
      "React Server Components",
      "文件系统路由"
    ],
    "body": {
      "raw": "\n# Next.js App Router 完全指南\n\nNext.js 13 引入了全新的 App Router，这是基于 React Server Components 构建的下一代路由系统。本文将全面介绍 App Router 的核心概念和最佳实践。\n\n## App Router vs Pages Router\n\n### Pages Router (传统方式)\n```\npages/\n├── index.js          // /\n├── about.js          // /about\n└── blog/\n    ├── index.js      // /blog\n    └── [slug].js     // /blog/[slug]\n```\n\n### App Router (新方式)\n```\napp/\n├── page.tsx          // /\n├── about/\n│   └── page.tsx      // /about\n└── blog/\n    ├── page.tsx      // /blog\n    └── [slug]/\n        └── page.tsx  // /blog/[slug]\n```\n\n## 核心概念\n\n### 1. 文件约定\n\nApp Router 使用特殊的文件名来定义路由行为：\n\n- `page.tsx`: 定义路由页面\n- `layout.tsx`: 定义布局\n- `loading.tsx`: 定义加载状态\n- `error.tsx`: 定义错误页面\n- `not-found.tsx`: 定义 404 页面\n- `route.tsx`: 定义 API 路由\n\n### 2. 布局系统\n\n#### 根布局 (必需)\n\n```tsx\n// app/layout.tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"zh\">\n      <body>\n        <header>\n          <nav>全局导航</nav>\n        </header>\n        <main>{children}</main>\n        <footer>全局页脚</footer>\n      </body>\n    </html>\n  );\n}\n```\n\n#### 嵌套布局\n\n```tsx\n// app/blog/layout.tsx\nexport default function BlogLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <div className=\"blog-container\">\n      <aside>\n        <h2>博客侧边栏</h2>\n        <nav>博客导航</nav>\n      </aside>\n      <div className=\"blog-content\">\n        {children}\n      </div>\n    </div>\n  );\n}\n```\n\n### 3. 页面组件\n\n```tsx\n// app/blog/page.tsx\nexport default function BlogPage() {\n  return (\n    <div>\n      <h1>博客首页</h1>\n      <p>欢迎来到我的博客</p>\n    </div>\n  );\n}\n```\n\n### 4. 动态路由\n\n#### 单个动态段\n\n```tsx\n// app/blog/[slug]/page.tsx\nexport default function BlogPost({\n  params,\n}: {\n  params: { slug: string };\n}) {\n  return (\n    <div>\n      <h1>文章: {params.slug}</h1>\n    </div>\n  );\n}\n```\n\n#### 多个动态段\n\n```tsx\n// app/blog/[category]/[slug]/page.tsx\nexport default function CategoryPost({\n  params,\n}: {\n  params: { category: string; slug: string };\n}) {\n  return (\n    <div>\n      <h1>分类: {params.category}</h1>\n      <h2>文章: {params.slug}</h2>\n    </div>\n  );\n}\n```\n\n#### 捕获所有路由\n\n```tsx\n// app/docs/[...slug]/page.tsx\nexport default function DocsPage({\n  params,\n}: {\n  params: { slug: string[] };\n}) {\n  return (\n    <div>\n      <h1>文档路径: {params.slug.join('/')}</h1>\n    </div>\n  );\n}\n```\n\n## 服务器组件 vs 客户端组件\n\n### 服务器组件 (默认)\n\n```tsx\n// 这是一个服务器组件\nasync function BlogPost({ params }: { params: { slug: string } }) {\n  // 可以直接在服务器端获取数据\n  const post = await getPost(params.slug);\n\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </article>\n  );\n}\n```\n\n### 客户端组件\n\n```tsx\n'use client'; // 标记为客户端组件\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>计数: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        增加\n      </button>\n    </div>\n  );\n}\n```\n\n## 数据获取\n\n### 服务器端数据获取\n\n```tsx\n// app/posts/page.tsx\nasync function getPosts() {\n  const res = await fetch('https://api.example.com/posts', {\n    // 可以配置缓存策略\n    next: { revalidate: 3600 } // 1小时后重新验证\n  });\n\n  if (!res.ok) {\n    throw new Error('Failed to fetch posts');\n  }\n\n  return res.json();\n}\n\nexport default async function PostsPage() {\n  const posts = await getPosts();\n\n  return (\n    <div>\n      <h1>文章列表</h1>\n      {posts.map((post: any) => (\n        <div key={post.id}>\n          <h2>{post.title}</h2>\n          <p>{post.excerpt}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n### 并行数据获取\n\n```tsx\nasync function getUser(id: string) {\n  const res = await fetch(`/api/users/${id}`);\n  return res.json();\n}\n\nasync function getUserPosts(id: string) {\n  const res = await fetch(`/api/users/${id}/posts`);\n  return res.json();\n}\n\nexport default async function UserProfile({\n  params,\n}: {\n  params: { id: string };\n}) {\n  // 并行获取数据\n  const [user, posts] = await Promise.all([\n    getUser(params.id),\n    getUserPosts(params.id),\n  ]);\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <div>\n        <h2>用户文章</h2>\n        {posts.map((post: any) => (\n          <div key={post.id}>{post.title}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\n## 加载状态\n\n```tsx\n// app/blog/loading.tsx\nexport default function Loading() {\n  return (\n    <div className=\"loading-container\">\n      <div className=\"spinner\"></div>\n      <p>加载中...</p>\n    </div>\n  );\n}\n```\n\n## 错误处理\n\n```tsx\n// app/blog/error.tsx\n'use client';\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string };\n  reset: () => void;\n}) {\n  return (\n    <div className=\"error-container\">\n      <h2>出错了！</h2>\n      <p>{error.message}</p>\n      <button onClick={reset}>重试</button>\n    </div>\n  );\n}\n```\n\n## 路由组\n\n使用括号创建路由组，不影响 URL 结构：\n\n```\napp/\n├── (marketing)/\n│   ├── about/\n│   │   └── page.tsx     // /about\n│   └── contact/\n│       └── page.tsx     // /contact\n└── (shop)/\n    ├── products/\n    │   └── page.tsx     // /products\n    └── cart/\n        └── page.tsx     // /cart\n```\n\n每个路由组可以有自己的布局：\n\n```tsx\n// app/(marketing)/layout.tsx\nexport default function MarketingLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <div className=\"marketing-layout\">\n      <nav>营销页面导航</nav>\n      {children}\n    </div>\n  );\n}\n```\n\n## 拦截路由\n\n使用 `(..)` 语法拦截路由：\n\n```\napp/\n├── feed/\n│   └── page.tsx\n├── photo/\n│   └── [id]/\n│       └── page.tsx\n└── @modal/\n    └── (..)photo/\n        └── [id]/\n            └── page.tsx\n```\n\n## 并行路由\n\n使用 `@` 语法创建并行路由：\n\n```tsx\n// app/layout.tsx\nexport default function Layout({\n  children,\n  analytics,\n  team,\n}: {\n  children: React.ReactNode;\n  analytics: React.ReactNode;\n  team: React.ReactNode;\n}) {\n  return (\n    <>\n      {children}\n      {analytics}\n      {team}\n    </>\n  );\n}\n```\n\n## 最佳实践\n\n### 1. 合理使用服务器组件和客户端组件\n\n```tsx\n// 服务器组件负责数据获取\nasync function PostList() {\n  const posts = await getPosts();\n\n  return (\n    <div>\n      {posts.map(post => (\n        <PostCard key={post.id} post={post} />\n      ))}\n    </div>\n  );\n}\n\n// 客户端组件负责交互\n'use client';\nfunction PostCard({ post }) {\n  const [liked, setLiked] = useState(false);\n\n  return (\n    <div>\n      <h3>{post.title}</h3>\n      <button onClick={() => setLiked(!liked)}>\n        {liked ? '❤️' : '🤍'}\n      </button>\n    </div>\n  );\n}\n```\n\n### 2. 优化数据获取\n\n```tsx\n// 使用适当的缓存策略\nasync function getData() {\n  const res = await fetch('https://api.example.com/data', {\n    next: {\n      revalidate: 3600, // 静态重新生成\n      tags: ['posts'] // 标签重新验证\n    }\n  });\n\n  return res.json();\n}\n```\n\n### 3. 错误边界和加载状态\n\n为每个路由段提供适当的错误处理和加载状态：\n\n```\napp/\n├── dashboard/\n│   ├── loading.tsx      // 仪表板加载状态\n│   ├── error.tsx        // 仪表板错误处理\n│   ├── page.tsx\n│   └── analytics/\n│       ├── loading.tsx  // 分析页面加载状态\n│       ├── error.tsx    // 分析页面错误处理\n│       └── page.tsx\n```\n\n## 总结\n\nNext.js App Router 带来了许多强大的特性：\n\n- **基于文件系统的路由**: 直观的路由结构\n- **布局系统**: 灵活的嵌套布局\n- **服务器组件**: 更好的性能和 SEO\n- **流式渲染**: 改善用户体验\n- **并行路由**: 复杂 UI 的解决方案\n\nApp Router 代表了 React 和 Next.js 的未来方向，值得我们深入学习和实践。\n",
      "html": "<h1>Next.js App Router 完全指南</h1>\n<p>Next.js 13 引入了全新的 App Router，这是基于 React Server Components 构建的下一代路由系统。本文将全面介绍 App Router 的核心概念和最佳实践。</p>\n<h2>App Router vs Pages Router</h2>\n<h3>Pages Router (传统方式)</h3>\n<pre><code>pages/\n├── index.js          // /\n├── about.js          // /about\n└── blog/\n    ├── index.js      // /blog\n    └── [slug].js     // /blog/[slug]\n</code></pre>\n<h3>App Router (新方式)</h3>\n<pre><code>app/\n├── page.tsx          // /\n├── about/\n│   └── page.tsx      // /about\n└── blog/\n    ├── page.tsx      // /blog\n    └── [slug]/\n        └── page.tsx  // /blog/[slug]\n</code></pre>\n<h2>核心概念</h2>\n<h3>1. 文件约定</h3>\n<p>App Router 使用特殊的文件名来定义路由行为：</p>\n<ul>\n<li><code>page.tsx</code>: 定义路由页面</li>\n<li><code>layout.tsx</code>: 定义布局</li>\n<li><code>loading.tsx</code>: 定义加载状态</li>\n<li><code>error.tsx</code>: 定义错误页面</li>\n<li><code>not-found.tsx</code>: 定义 404 页面</li>\n<li><code>route.tsx</code>: 定义 API 路由</li>\n</ul>\n<h3>2. 布局系统</h3>\n<h4>根布局 (必需)</h4>\n<pre><code class=\"language-tsx\">// app/layout.tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &#x3C;html lang=\"zh\">\n      &#x3C;body>\n        &#x3C;header>\n          &#x3C;nav>全局导航&#x3C;/nav>\n        &#x3C;/header>\n        &#x3C;main>{children}&#x3C;/main>\n        &#x3C;footer>全局页脚&#x3C;/footer>\n      &#x3C;/body>\n    &#x3C;/html>\n  );\n}\n</code></pre>\n<h4>嵌套布局</h4>\n<pre><code class=\"language-tsx\">// app/blog/layout.tsx\nexport default function BlogLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &#x3C;div className=\"blog-container\">\n      &#x3C;aside>\n        &#x3C;h2>博客侧边栏&#x3C;/h2>\n        &#x3C;nav>博客导航&#x3C;/nav>\n      &#x3C;/aside>\n      &#x3C;div className=\"blog-content\">\n        {children}\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>3. 页面组件</h3>\n<pre><code class=\"language-tsx\">// app/blog/page.tsx\nexport default function BlogPage() {\n  return (\n    &#x3C;div>\n      &#x3C;h1>博客首页&#x3C;/h1>\n      &#x3C;p>欢迎来到我的博客&#x3C;/p>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>4. 动态路由</h3>\n<h4>单个动态段</h4>\n<pre><code class=\"language-tsx\">// app/blog/[slug]/page.tsx\nexport default function BlogPost({\n  params,\n}: {\n  params: { slug: string };\n}) {\n  return (\n    &#x3C;div>\n      &#x3C;h1>文章: {params.slug}&#x3C;/h1>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h4>多个动态段</h4>\n<pre><code class=\"language-tsx\">// app/blog/[category]/[slug]/page.tsx\nexport default function CategoryPost({\n  params,\n}: {\n  params: { category: string; slug: string };\n}) {\n  return (\n    &#x3C;div>\n      &#x3C;h1>分类: {params.category}&#x3C;/h1>\n      &#x3C;h2>文章: {params.slug}&#x3C;/h2>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h4>捕获所有路由</h4>\n<pre><code class=\"language-tsx\">// app/docs/[...slug]/page.tsx\nexport default function DocsPage({\n  params,\n}: {\n  params: { slug: string[] };\n}) {\n  return (\n    &#x3C;div>\n      &#x3C;h1>文档路径: {params.slug.join('/')}&#x3C;/h1>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>服务器组件 vs 客户端组件</h2>\n<h3>服务器组件 (默认)</h3>\n<pre><code class=\"language-tsx\">// 这是一个服务器组件\nasync function BlogPost({ params }: { params: { slug: string } }) {\n  // 可以直接在服务器端获取数据\n  const post = await getPost(params.slug);\n\n  return (\n    &#x3C;article>\n      &#x3C;h1>{post.title}&#x3C;/h1>\n      &#x3C;p>{post.content}&#x3C;/p>\n    &#x3C;/article>\n  );\n}\n</code></pre>\n<h3>客户端组件</h3>\n<pre><code class=\"language-tsx\">'use client'; // 标记为客户端组件\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &#x3C;div>\n      &#x3C;p>计数: {count}&#x3C;/p>\n      &#x3C;button onClick={() => setCount(count + 1)}>\n        增加\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>数据获取</h2>\n<h3>服务器端数据获取</h3>\n<pre><code class=\"language-tsx\">// app/posts/page.tsx\nasync function getPosts() {\n  const res = await fetch('https://api.example.com/posts', {\n    // 可以配置缓存策略\n    next: { revalidate: 3600 } // 1小时后重新验证\n  });\n\n  if (!res.ok) {\n    throw new Error('Failed to fetch posts');\n  }\n\n  return res.json();\n}\n\nexport default async function PostsPage() {\n  const posts = await getPosts();\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>文章列表&#x3C;/h1>\n      {posts.map((post: any) => (\n        &#x3C;div key={post.id}>\n          &#x3C;h2>{post.title}&#x3C;/h2>\n          &#x3C;p>{post.excerpt}&#x3C;/p>\n        &#x3C;/div>\n      ))}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>并行数据获取</h3>\n<pre><code class=\"language-tsx\">async function getUser(id: string) {\n  const res = await fetch(`/api/users/${id}`);\n  return res.json();\n}\n\nasync function getUserPosts(id: string) {\n  const res = await fetch(`/api/users/${id}/posts`);\n  return res.json();\n}\n\nexport default async function UserProfile({\n  params,\n}: {\n  params: { id: string };\n}) {\n  // 并行获取数据\n  const [user, posts] = await Promise.all([\n    getUser(params.id),\n    getUserPosts(params.id),\n  ]);\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>{user.name}&#x3C;/h1>\n      &#x3C;div>\n        &#x3C;h2>用户文章&#x3C;/h2>\n        {posts.map((post: any) => (\n          &#x3C;div key={post.id}>{post.title}&#x3C;/div>\n        ))}\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>加载状态</h2>\n<pre><code class=\"language-tsx\">// app/blog/loading.tsx\nexport default function Loading() {\n  return (\n    &#x3C;div className=\"loading-container\">\n      &#x3C;div className=\"spinner\">&#x3C;/div>\n      &#x3C;p>加载中...&#x3C;/p>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>错误处理</h2>\n<pre><code class=\"language-tsx\">// app/blog/error.tsx\n'use client';\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error &#x26; { digest?: string };\n  reset: () => void;\n}) {\n  return (\n    &#x3C;div className=\"error-container\">\n      &#x3C;h2>出错了！&#x3C;/h2>\n      &#x3C;p>{error.message}&#x3C;/p>\n      &#x3C;button onClick={reset}>重试&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>路由组</h2>\n<p>使用括号创建路由组，不影响 URL 结构：</p>\n<pre><code>app/\n├── (marketing)/\n│   ├── about/\n│   │   └── page.tsx     // /about\n│   └── contact/\n│       └── page.tsx     // /contact\n└── (shop)/\n    ├── products/\n    │   └── page.tsx     // /products\n    └── cart/\n        └── page.tsx     // /cart\n</code></pre>\n<p>每个路由组可以有自己的布局：</p>\n<pre><code class=\"language-tsx\">// app/(marketing)/layout.tsx\nexport default function MarketingLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &#x3C;div className=\"marketing-layout\">\n      &#x3C;nav>营销页面导航&#x3C;/nav>\n      {children}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>拦截路由</h2>\n<p>使用 <code>(..)</code> 语法拦截路由：</p>\n<pre><code>app/\n├── feed/\n│   └── page.tsx\n├── photo/\n│   └── [id]/\n│       └── page.tsx\n└── @modal/\n    └── (..)photo/\n        └── [id]/\n            └── page.tsx\n</code></pre>\n<h2>并行路由</h2>\n<p>使用 <code>@</code> 语法创建并行路由：</p>\n<pre><code class=\"language-tsx\">// app/layout.tsx\nexport default function Layout({\n  children,\n  analytics,\n  team,\n}: {\n  children: React.ReactNode;\n  analytics: React.ReactNode;\n  team: React.ReactNode;\n}) {\n  return (\n    &#x3C;>\n      {children}\n      {analytics}\n      {team}\n    &#x3C;/>\n  );\n}\n</code></pre>\n<h2>最佳实践</h2>\n<h3>1. 合理使用服务器组件和客户端组件</h3>\n<pre><code class=\"language-tsx\">// 服务器组件负责数据获取\nasync function PostList() {\n  const posts = await getPosts();\n\n  return (\n    &#x3C;div>\n      {posts.map(post => (\n        &#x3C;PostCard key={post.id} post={post} />\n      ))}\n    &#x3C;/div>\n  );\n}\n\n// 客户端组件负责交互\n'use client';\nfunction PostCard({ post }) {\n  const [liked, setLiked] = useState(false);\n\n  return (\n    &#x3C;div>\n      &#x3C;h3>{post.title}&#x3C;/h3>\n      &#x3C;button onClick={() => setLiked(!liked)}>\n        {liked ? '❤️' : '🤍'}\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>2. 优化数据获取</h3>\n<pre><code class=\"language-tsx\">// 使用适当的缓存策略\nasync function getData() {\n  const res = await fetch('https://api.example.com/data', {\n    next: {\n      revalidate: 3600, // 静态重新生成\n      tags: ['posts'] // 标签重新验证\n    }\n  });\n\n  return res.json();\n}\n</code></pre>\n<h3>3. 错误边界和加载状态</h3>\n<p>为每个路由段提供适当的错误处理和加载状态：</p>\n<pre><code>app/\n├── dashboard/\n│   ├── loading.tsx      // 仪表板加载状态\n│   ├── error.tsx        // 仪表板错误处理\n│   ├── page.tsx\n│   └── analytics/\n│       ├── loading.tsx  // 分析页面加载状态\n│       ├── error.tsx    // 分析页面错误处理\n│       └── page.tsx\n</code></pre>\n<h2>总结</h2>\n<p>Next.js App Router 带来了许多强大的特性：</p>\n<ul>\n<li><strong>基于文件系统的路由</strong>: 直观的路由结构</li>\n<li><strong>布局系统</strong>: 灵活的嵌套布局</li>\n<li><strong>服务器组件</strong>: 更好的性能和 SEO</li>\n<li><strong>流式渲染</strong>: 改善用户体验</li>\n<li><strong>并行路由</strong>: 复杂 UI 的解决方案</li>\n</ul>\n<p>App Router 代表了 React 和 Next.js 的未来方向，值得我们深入学习和实践。</p>"
    },
    "_id": "articles/nextjs-app-router-guide.md",
    "_raw": {
      "sourceFilePath": "articles/nextjs-app-router-guide.md",
      "sourceFileName": "nextjs-app-router-guide.md",
      "sourceFileDir": "articles",
      "contentType": "markdown",
      "flattenedPath": "articles/nextjs-app-router-guide"
    },
    "type": "Article",
    "slug": "nextjs-app-router-guide",
    "readingTime": {
      "text": "7 min read",
      "minutes": 6.71,
      "time": 402600,
      "words": 1342
    },
    "url": "/articles/nextjs-app-router-guide"
  },
  {
    "title": "React 18 并发特性深度解析",
    "excerpt": "深入探讨 React 18 的并发渲染机制，包括 useTransition、useDeferredValue 等新 Hook 的使用场景和最佳实践。",
    "publishedAt": "2024-01-15T00:00:00.000Z",
    "updatedAt": "2024-01-20T00:00:00.000Z",
    "author": "li-lingfeng",
    "category": "frontend",
    "tags": [
      "react",
      "typescript"
    ],
    "featured": true,
    "published": true,
    "image": "/images/articles/react-18-concurrent.jpg",
    "seoTitle": "React 18 并发特性深度解析 - 提升应用性能的新方法",
    "seoDescription": "学习 React 18 的并发特性，掌握 useTransition、useDeferredValue 等新 Hook，提升应用性能和用户体验",
    "seoKeywords": [
      "React 18",
      "并发渲染",
      "useTransition",
      "useDeferredValue",
      "性能优化"
    ],
    "body": {
      "raw": "\n# React 18 并发特性深度解析\n\nReact 18 引入了期待已久的并发特性，这些特性让我们能够构建更加流畅和响应式的用户界面。本文将深入探讨这些新特性的工作原理和实际应用。\n\n## 什么是并发渲染？\n\n并发渲染是 React 18 的核心特性，它允许 React 在渲染过程中暂停和恢复工作。这意味着：\n\n- React 可以同时准备多个版本的 UI\n- 高优先级的更新可以中断低优先级的更新\n- 用户界面保持响应，即使在处理大量计算时\n\n## useTransition Hook\n\n`useTransition` 是 React 18 中最重要的新 Hook 之一，它允许我们将状态更新标记为非紧急的。\n\n### 基本用法\n\n```jsx\nimport { useState, useTransition } from 'react';\n\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSearch = (newQuery) => {\n    setQuery(newQuery); // 紧急更新\n\n    startTransition(() => {\n      // 非紧急更新\n      setResults(searchData(newQuery));\n    });\n  };\n\n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => handleSearch(e.target.value)}\n        placeholder=\"搜索...\"\n      />\n\n      {isPending && <div>搜索中...</div>}\n\n      <SearchResultsList results={results} />\n    </div>\n  );\n}\n```\n\n### 实际应用场景\n\n1. **搜索功能**: 输入框的更新是紧急的，搜索结果的更新可以延迟\n2. **标签页切换**: 标签的激活状态是紧急的，内容加载可以延迟\n3. **数据过滤**: 过滤条件的更新是紧急的，结果渲染可以延迟\n\n## useDeferredValue Hook\n\n`useDeferredValue` 允许我们延迟更新 UI 的某些部分，直到更紧急的更新完成。\n\n### 基本用法\n\n```jsx\nimport { useState, useDeferredValue, useMemo } from 'react';\n\nfunction ProductList({ searchQuery }) {\n  const deferredQuery = useDeferredValue(searchQuery);\n\n  const filteredProducts = useMemo(() => {\n    return products.filter(product =>\n      product.name.toLowerCase().includes(deferredQuery.toLowerCase())\n    );\n  }, [deferredQuery]);\n\n  return (\n    <div>\n      {filteredProducts.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  );\n}\n```\n\n### 与 useTransition 的区别\n\n- `useTransition`: 控制状态更新的优先级\n- `useDeferredValue`: 延迟值的更新，通常用于昂贵的计算\n\n## Suspense 的改进\n\nReact 18 中的 Suspense 不仅支持代码分割，还支持数据获取：\n\n```jsx\nfunction App() {\n  return (\n    <Suspense fallback={<GlobalSpinner />}>\n      <Header />\n      <Suspense fallback={<SidebarSkeleton />}>\n        <Sidebar />\n      </Suspense>\n      <Suspense fallback={<ContentSkeleton />}>\n        <MainContent />\n      </Suspense>\n    </Suspense>\n  );\n}\n```\n\n## 自动批处理\n\nReact 18 自动批处理所有状态更新，包括在 Promise、setTimeout 和原生事件处理器中的更新：\n\n```jsx\n// React 18 中，这些更新会被自动批处理\nfunction handleClick() {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // React 只会重新渲染一次\n}\n\n// 如果需要退出批处理，可以使用 flushSync\nimport { flushSync } from 'react-dom';\n\nfunction handleClick() {\n  flushSync(() => {\n    setCount(c => c + 1);\n  });\n  // React 已经重新渲染了\n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React 再次重新渲染了\n}\n```\n\n## 最佳实践\n\n### 1. 识别紧急和非紧急更新\n\n```jsx\n// 紧急：用户输入、悬停、点击\nconst handleInputChange = (value) => {\n  setValue(value); // 紧急更新\n\n  startTransition(() => {\n    setSearchResults(search(value)); // 非紧急更新\n  });\n};\n```\n\n### 2. 使用 useMemo 优化昂贵计算\n\n```jsx\nconst ExpensiveComponent = ({ data }) => {\n  const deferredData = useDeferredValue(data);\n\n  const expensiveValue = useMemo(() => {\n    return performExpensiveCalculation(deferredData);\n  }, [deferredData]);\n\n  return <div>{expensiveValue}</div>;\n};\n```\n\n### 3. 合理使用 Suspense 边界\n\n```jsx\n// 为不同的 UI 部分设置不同的 Suspense 边界\nfunction Dashboard() {\n  return (\n    <div>\n      <Suspense fallback={<HeaderSkeleton />}>\n        <Header />\n      </Suspense>\n\n      <div className=\"main-content\">\n        <Suspense fallback={<SidebarSkeleton />}>\n          <Sidebar />\n        </Suspense>\n\n        <Suspense fallback={<ContentSkeleton />}>\n          <MainContent />\n        </Suspense>\n      </div>\n    </div>\n  );\n}\n```\n\n## 性能监控\n\n使用 React DevTools Profiler 来监控并发特性的效果：\n\n```jsx\nimport { Profiler } from 'react';\n\nfunction onRenderCallback(id, phase, actualDuration) {\n  console.log('Component:', id);\n  console.log('Phase:', phase);\n  console.log('Duration:', actualDuration);\n}\n\nfunction App() {\n  return (\n    <Profiler id=\"App\" onRender={onRenderCallback}>\n      <MyComponent />\n    </Profiler>\n  );\n}\n```\n\n## 总结\n\nReact 18 的并发特性为我们提供了强大的工具来构建更加流畅的用户界面：\n\n- **useTransition**: 标记非紧急更新，保持界面响应\n- **useDeferredValue**: 延迟昂贵计算，优化性能\n- **改进的 Suspense**: 更好的加载状态管理\n- **自动批处理**: 减少不必要的重新渲染\n\n这些特性需要我们重新思考应用的状态管理和更新策略。通过合理使用这些工具，我们可以显著提升应用的性能和用户体验。\n\n记住，并发特性是渐进式的增强，你可以逐步在现有应用中采用这些特性，而不需要大规模重构。\n",
      "html": "<h1>React 18 并发特性深度解析</h1>\n<p>React 18 引入了期待已久的并发特性，这些特性让我们能够构建更加流畅和响应式的用户界面。本文将深入探讨这些新特性的工作原理和实际应用。</p>\n<h2>什么是并发渲染？</h2>\n<p>并发渲染是 React 18 的核心特性，它允许 React 在渲染过程中暂停和恢复工作。这意味着：</p>\n<ul>\n<li>React 可以同时准备多个版本的 UI</li>\n<li>高优先级的更新可以中断低优先级的更新</li>\n<li>用户界面保持响应，即使在处理大量计算时</li>\n</ul>\n<h2>useTransition Hook</h2>\n<p><code>useTransition</code> 是 React 18 中最重要的新 Hook 之一，它允许我们将状态更新标记为非紧急的。</p>\n<h3>基本用法</h3>\n<pre><code class=\"language-jsx\">import { useState, useTransition } from 'react';\n\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSearch = (newQuery) => {\n    setQuery(newQuery); // 紧急更新\n\n    startTransition(() => {\n      // 非紧急更新\n      setResults(searchData(newQuery));\n    });\n  };\n\n  return (\n    &#x3C;div>\n      &#x3C;input\n        value={query}\n        onChange={(e) => handleSearch(e.target.value)}\n        placeholder=\"搜索...\"\n      />\n\n      {isPending &#x26;&#x26; &#x3C;div>搜索中...&#x3C;/div>}\n\n      &#x3C;SearchResultsList results={results} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>实际应用场景</h3>\n<ol>\n<li><strong>搜索功能</strong>: 输入框的更新是紧急的，搜索结果的更新可以延迟</li>\n<li><strong>标签页切换</strong>: 标签的激活状态是紧急的，内容加载可以延迟</li>\n<li><strong>数据过滤</strong>: 过滤条件的更新是紧急的，结果渲染可以延迟</li>\n</ol>\n<h2>useDeferredValue Hook</h2>\n<p><code>useDeferredValue</code> 允许我们延迟更新 UI 的某些部分，直到更紧急的更新完成。</p>\n<h3>基本用法</h3>\n<pre><code class=\"language-jsx\">import { useState, useDeferredValue, useMemo } from 'react';\n\nfunction ProductList({ searchQuery }) {\n  const deferredQuery = useDeferredValue(searchQuery);\n\n  const filteredProducts = useMemo(() => {\n    return products.filter(product =>\n      product.name.toLowerCase().includes(deferredQuery.toLowerCase())\n    );\n  }, [deferredQuery]);\n\n  return (\n    &#x3C;div>\n      {filteredProducts.map(product => (\n        &#x3C;ProductCard key={product.id} product={product} />\n      ))}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>与 useTransition 的区别</h3>\n<ul>\n<li><code>useTransition</code>: 控制状态更新的优先级</li>\n<li><code>useDeferredValue</code>: 延迟值的更新，通常用于昂贵的计算</li>\n</ul>\n<h2>Suspense 的改进</h2>\n<p>React 18 中的 Suspense 不仅支持代码分割，还支持数据获取：</p>\n<pre><code class=\"language-jsx\">function App() {\n  return (\n    &#x3C;Suspense fallback={&#x3C;GlobalSpinner />}>\n      &#x3C;Header />\n      &#x3C;Suspense fallback={&#x3C;SidebarSkeleton />}>\n        &#x3C;Sidebar />\n      &#x3C;/Suspense>\n      &#x3C;Suspense fallback={&#x3C;ContentSkeleton />}>\n        &#x3C;MainContent />\n      &#x3C;/Suspense>\n    &#x3C;/Suspense>\n  );\n}\n</code></pre>\n<h2>自动批处理</h2>\n<p>React 18 自动批处理所有状态更新，包括在 Promise、setTimeout 和原生事件处理器中的更新：</p>\n<pre><code class=\"language-jsx\">// React 18 中，这些更新会被自动批处理\nfunction handleClick() {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // React 只会重新渲染一次\n}\n\n// 如果需要退出批处理，可以使用 flushSync\nimport { flushSync } from 'react-dom';\n\nfunction handleClick() {\n  flushSync(() => {\n    setCount(c => c + 1);\n  });\n  // React 已经重新渲染了\n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React 再次重新渲染了\n}\n</code></pre>\n<h2>最佳实践</h2>\n<h3>1. 识别紧急和非紧急更新</h3>\n<pre><code class=\"language-jsx\">// 紧急：用户输入、悬停、点击\nconst handleInputChange = (value) => {\n  setValue(value); // 紧急更新\n\n  startTransition(() => {\n    setSearchResults(search(value)); // 非紧急更新\n  });\n};\n</code></pre>\n<h3>2. 使用 useMemo 优化昂贵计算</h3>\n<pre><code class=\"language-jsx\">const ExpensiveComponent = ({ data }) => {\n  const deferredData = useDeferredValue(data);\n\n  const expensiveValue = useMemo(() => {\n    return performExpensiveCalculation(deferredData);\n  }, [deferredData]);\n\n  return &#x3C;div>{expensiveValue}&#x3C;/div>;\n};\n</code></pre>\n<h3>3. 合理使用 Suspense 边界</h3>\n<pre><code class=\"language-jsx\">// 为不同的 UI 部分设置不同的 Suspense 边界\nfunction Dashboard() {\n  return (\n    &#x3C;div>\n      &#x3C;Suspense fallback={&#x3C;HeaderSkeleton />}>\n        &#x3C;Header />\n      &#x3C;/Suspense>\n\n      &#x3C;div className=\"main-content\">\n        &#x3C;Suspense fallback={&#x3C;SidebarSkeleton />}>\n          &#x3C;Sidebar />\n        &#x3C;/Suspense>\n\n        &#x3C;Suspense fallback={&#x3C;ContentSkeleton />}>\n          &#x3C;MainContent />\n        &#x3C;/Suspense>\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>性能监控</h2>\n<p>使用 React DevTools Profiler 来监控并发特性的效果：</p>\n<pre><code class=\"language-jsx\">import { Profiler } from 'react';\n\nfunction onRenderCallback(id, phase, actualDuration) {\n  console.log('Component:', id);\n  console.log('Phase:', phase);\n  console.log('Duration:', actualDuration);\n}\n\nfunction App() {\n  return (\n    &#x3C;Profiler id=\"App\" onRender={onRenderCallback}>\n      &#x3C;MyComponent />\n    &#x3C;/Profiler>\n  );\n}\n</code></pre>\n<h2>总结</h2>\n<p>React 18 的并发特性为我们提供了强大的工具来构建更加流畅的用户界面：</p>\n<ul>\n<li><strong>useTransition</strong>: 标记非紧急更新，保持界面响应</li>\n<li><strong>useDeferredValue</strong>: 延迟昂贵计算，优化性能</li>\n<li><strong>改进的 Suspense</strong>: 更好的加载状态管理</li>\n<li><strong>自动批处理</strong>: 减少不必要的重新渲染</li>\n</ul>\n<p>这些特性需要我们重新思考应用的状态管理和更新策略。通过合理使用这些工具，我们可以显著提升应用的性能和用户体验。</p>\n<p>记住，并发特性是渐进式的增强，你可以逐步在现有应用中采用这些特性，而不需要大规模重构。</p>"
    },
    "_id": "articles/react-18-concurrent-features.md",
    "_raw": {
      "sourceFilePath": "articles/react-18-concurrent-features.md",
      "sourceFileName": "react-18-concurrent-features.md",
      "sourceFileDir": "articles",
      "contentType": "markdown",
      "flattenedPath": "articles/react-18-concurrent-features"
    },
    "type": "Article",
    "slug": "react-18-concurrent-features",
    "readingTime": {
      "text": "6 min read",
      "minutes": 5.1,
      "time": 306000,
      "words": 1020
    },
    "url": "/articles/react-18-concurrent-features"
  },
  {
    "title": "TypeScript 高级类型实战指南",
    "excerpt": "深入探索 TypeScript 的高级类型系统，包括条件类型、映射类型、模板字面量类型等，通过实际案例学习如何构建类型安全的应用。",
    "publishedAt": "2024-01-28T00:00:00.000Z",
    "author": "li-lingfeng",
    "category": "frontend",
    "tags": [
      "typescript",
      "javascript"
    ],
    "featured": false,
    "published": true,
    "image": "/images/articles/typescript-advanced.jpg",
    "seoTitle": "TypeScript 高级类型实战指南 - 掌握类型编程",
    "seoDescription": "学习 TypeScript 高级类型系统，包括条件类型、映射类型、模板字面量类型等，提升代码质量和开发效率",
    "seoKeywords": [
      "TypeScript",
      "高级类型",
      "条件类型",
      "映射类型",
      "类型编程"
    ],
    "body": {
      "raw": "\n# TypeScript 高级类型实战指南\n\nTypeScript 的类型系统非常强大，掌握高级类型技巧可以让我们写出更安全、更优雅的代码。本文将深入探讨 TypeScript 的高级类型特性。\n\n## 条件类型 (Conditional Types)\n\n条件类型允许我们根据条件选择类型，语法类似于三元运算符。\n\n### 基础语法\n\n```typescript\ntype ConditionalType<T> = T extends string ? string : number;\n\ntype Test1 = ConditionalType<string>; // string\ntype Test2 = ConditionalType<number>; // number\n```\n\n### 实际应用：类型守卫\n\n```typescript\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype Example1 = NonNullable<string | null>; // string\ntype Example2 = NonNullable<number | undefined>; // number\n```\n\n### 分布式条件类型\n\n当条件类型作用于联合类型时，会分布到每个成员：\n\n```typescript\ntype ToArray<T> = T extends any ? T[] : never;\n\ntype StrArrOrNumArr = ToArray<string | number>; // string[] | number[]\n```\n\n## 映射类型 (Mapped Types)\n\n映射类型可以基于现有类型创建新类型。\n\n### 内置映射类型\n\n```typescript\n// Partial - 所有属性变为可选\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\n// Required - 所有属性变为必需\ntype Required<T> = {\n  [P in keyof T]-?: T[P];\n};\n\n// Readonly - 所有属性变为只读\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n```\n\n### 自定义映射类型\n\n```typescript\n// 为所有属性添加前缀\ntype Prefixed<T, P extends string> = {\n  [K in keyof T as `${P}${string & K}`]: T[K];\n};\n\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype PrefixedUser = Prefixed<User, 'user_'>;\n// { user_name: string; user_age: number; }\n```\n\n## 模板字面量类型 (Template Literal Types)\n\nTypeScript 4.1 引入了模板字面量类型，允许我们在类型层面操作字符串。\n\n### 基础用法\n\n```typescript\ntype World = \"world\";\ntype Greeting = `hello ${World}`; // \"hello world\"\n```\n\n### 实际应用：事件系统\n\n```typescript\ntype EventName<T extends string> = `on${Capitalize<T>}`;\n\ntype ButtonEvents = EventName<'click' | 'hover' | 'focus'>;\n// 'onClick' | 'onHover' | 'onFocus'\n\n// 事件处理器类型\ntype EventHandlers<T extends Record<string, any>> = {\n  [K in keyof T as EventName<string & K>]?: (event: T[K]) => void;\n};\n\ninterface Events {\n  click: MouseEvent;\n  hover: MouseEvent;\n  focus: FocusEvent;\n}\n\ntype Handlers = EventHandlers<Events>;\n// {\n//   onClick?: (event: MouseEvent) => void;\n//   onHover?: (event: MouseEvent) => void;\n//   onFocus?: (event: FocusEvent) => void;\n// }\n```\n\n## 工具类型组合\n\n### 深度只读类型\n\n```typescript\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\ninterface NestedObject {\n  user: {\n    profile: {\n      name: string;\n      settings: {\n        theme: string;\n      };\n    };\n  };\n}\n\ntype ReadonlyNested = DeepReadonly<NestedObject>;\n// 所有嵌套属性都变为只读\n```\n\n### 类型安全的路径访问\n\n```typescript\ntype PathKeys<T> = {\n  [K in keyof T]: T[K] extends object\n    ? K | `${string & K}.${PathKeys<T[K]>}`\n    : K;\n}[keyof T];\n\ntype GetByPath<T, P extends string> = P extends `${infer K}.${infer Rest}`\n  ? K extends keyof T\n    ? GetByPath<T[K], Rest>\n    : never\n  : P extends keyof T\n  ? T[P]\n  : never;\n\ninterface Data {\n  user: {\n    profile: {\n      name: string;\n      age: number;\n    };\n    settings: {\n      theme: 'light' | 'dark';\n    };\n  };\n}\n\ntype ValidPaths = PathKeys<Data>;\n// 'user' | 'user.profile' | 'user.profile.name' | 'user.profile.age' | 'user.settings' | 'user.settings.theme'\n\nfunction getValue<T, P extends PathKeys<T>>(obj: T, path: P): GetByPath<T, P> {\n  // 实现省略\n  return null as any;\n}\n\nconst data: Data = { /* ... */ };\nconst name = getValue(data, 'user.profile.name'); // string\nconst theme = getValue(data, 'user.settings.theme'); // 'light' | 'dark'\n```\n\n## 实际应用案例\n\n### 类型安全的 API 客户端\n\n```typescript\n// API 端点定义\ninterface ApiEndpoints {\n  '/users': {\n    GET: { response: User[] };\n    POST: { body: CreateUserRequest; response: User };\n  };\n  '/users/:id': {\n    GET: { params: { id: string }; response: User };\n    PUT: { params: { id: string }; body: UpdateUserRequest; response: User };\n    DELETE: { params: { id: string }; response: void };\n  };\n}\n\n// 提取方法类型\ntype Methods<T> = T extends Record<string, infer M> ? keyof M : never;\n\n// 提取请求参数类型\ntype RequestParams<\n  T extends Record<string, any>,\n  P extends keyof T,\n  M extends keyof T[P]\n> = T[P][M] extends { params: infer Params } ? Params : {};\n\n// 提取请求体类型\ntype RequestBody<\n  T extends Record<string, any>,\n  P extends keyof T,\n  M extends keyof T[P]\n> = T[P][M] extends { body: infer Body } ? Body : never;\n\n// 提取响应类型\ntype ResponseType<\n  T extends Record<string, any>,\n  P extends keyof T,\n  M extends keyof T[P]\n> = T[P][M] extends { response: infer Response } ? Response : never;\n\n// API 客户端类型\nclass ApiClient<T extends Record<string, any>> {\n  async request<\n    P extends keyof T,\n    M extends Methods<T[P]>\n  >(\n    path: P,\n    method: M,\n    ...args: RequestBody<T, P, M> extends never\n      ? [params?: RequestParams<T, P, M>]\n      : [params: RequestParams<T, P, M>, body: RequestBody<T, P, M>]\n  ): Promise<ResponseType<T, P, M>> {\n    // 实现省略\n    return null as any;\n  }\n}\n\n// 使用示例\nconst api = new ApiClient<ApiEndpoints>();\n\n// 类型安全的 API 调用\nconst users = await api.request('/users', 'GET'); // User[]\nconst user = await api.request('/users/:id', 'GET', { id: '123' }); // User\nconst newUser = await api.request('/users', 'POST', {}, { name: 'John' }); // User\n```\n\n### 表单验证类型\n\n```typescript\n// 验证规则类型\ntype ValidationRule<T> = {\n  required?: boolean;\n  min?: T extends string ? number : T extends number ? number : never;\n  max?: T extends string ? number : T extends number ? number : never;\n  pattern?: T extends string ? RegExp : never;\n  custom?: (value: T) => boolean | string;\n};\n\n// 表单模式类型\ntype FormSchema<T> = {\n  [K in keyof T]: ValidationRule<T[K]>;\n};\n\n// 验证错误类型\ntype ValidationErrors<T> = {\n  [K in keyof T]?: string[];\n};\n\n// 表单验证器\nclass FormValidator<T extends Record<string, any>> {\n  constructor(private schema: FormSchema<T>) {}\n\n  validate(data: T): ValidationErrors<T> {\n    const errors: ValidationErrors<T> = {};\n\n    for (const key in this.schema) {\n      const rule = this.schema[key];\n      const value = data[key];\n      const fieldErrors: string[] = [];\n\n      if (rule.required && !value) {\n        fieldErrors.push('This field is required');\n      }\n\n      if (value && rule.min !== undefined) {\n        if (typeof value === 'string' && value.length < rule.min) {\n          fieldErrors.push(`Minimum length is ${rule.min}`);\n        }\n        if (typeof value === 'number' && value < rule.min) {\n          fieldErrors.push(`Minimum value is ${rule.min}`);\n        }\n      }\n\n      // 更多验证逻辑...\n\n      if (fieldErrors.length > 0) {\n        errors[key] = fieldErrors;\n      }\n    }\n\n    return errors;\n  }\n}\n\n// 使用示例\ninterface UserForm {\n  name: string;\n  email: string;\n  age: number;\n}\n\nconst validator = new FormValidator<UserForm>({\n  name: { required: true, min: 2 },\n  email: { required: true, pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ },\n  age: { required: true, min: 18, max: 120 }\n});\n\nconst errors = validator.validate({\n  name: 'John',\n  email: 'john@example.com',\n  age: 25\n});\n```\n\n## 性能考虑\n\n### 避免过度复杂的类型\n\n```typescript\n// ❌ 过度复杂，可能导致编译性能问题\ntype OverlyComplex<T> = T extends infer U\n  ? U extends Record<string, any>\n    ? {\n        [K in keyof U]: U[K] extends infer V\n          ? V extends Record<string, any>\n            ? OverlyComplex<V>\n            : V\n          : never;\n      }\n    : U\n  : never;\n\n// ✅ 简化版本\ntype Simplified<T> = T extends Record<string, any>\n  ? { [K in keyof T]: Simplified<T[K]> }\n  : T;\n```\n\n### 使用类型断言优化\n\n```typescript\n// 在确保类型安全的前提下使用断言\nfunction processData<T>(data: unknown): T {\n  // 运行时验证\n  if (isValidData(data)) {\n    return data as T;\n  }\n  throw new Error('Invalid data');\n}\n```\n\n## 最佳实践\n\n1. **渐进式采用**: 从简单类型开始，逐步引入高级特性\n2. **文档化复杂类型**: 为复杂的类型添加注释说明\n3. **测试类型**: 使用类型测试确保类型行为正确\n4. **性能监控**: 关注编译时间，避免过度复杂的类型\n\n```typescript\n// 类型测试示例\ntype Expect<T extends true> = T;\ntype Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;\n\n// 测试用例\ntype Test1 = Expect<Equal<ConditionalType<string>, string>>;\ntype Test2 = Expect<Equal<ConditionalType<number>, number>>;\n```\n\n## 总结\n\nTypeScript 的高级类型系统为我们提供了强大的工具来构建类型安全的应用：\n\n- **条件类型**: 根据条件选择类型\n- **映射类型**: 转换现有类型\n- **模板字面量类型**: 类型层面的字符串操作\n- **工具类型组合**: 构建复杂的类型逻辑\n\n掌握这些高级特性，能让我们的 TypeScript 代码更加健壮和可维护。记住，类型系统的目标是帮助我们写出更好的代码，而不是增加复杂性。在实际项目中，要根据需求合理使用这些特性。\n",
      "html": "<h1>TypeScript 高级类型实战指南</h1>\n<p>TypeScript 的类型系统非常强大，掌握高级类型技巧可以让我们写出更安全、更优雅的代码。本文将深入探讨 TypeScript 的高级类型特性。</p>\n<h2>条件类型 (Conditional Types)</h2>\n<p>条件类型允许我们根据条件选择类型，语法类似于三元运算符。</p>\n<h3>基础语法</h3>\n<pre><code class=\"language-typescript\">type ConditionalType&#x3C;T> = T extends string ? string : number;\n\ntype Test1 = ConditionalType&#x3C;string>; // string\ntype Test2 = ConditionalType&#x3C;number>; // number\n</code></pre>\n<h3>实际应用：类型守卫</h3>\n<pre><code class=\"language-typescript\">type NonNullable&#x3C;T> = T extends null | undefined ? never : T;\n\ntype Example1 = NonNullable&#x3C;string | null>; // string\ntype Example2 = NonNullable&#x3C;number | undefined>; // number\n</code></pre>\n<h3>分布式条件类型</h3>\n<p>当条件类型作用于联合类型时，会分布到每个成员：</p>\n<pre><code class=\"language-typescript\">type ToArray&#x3C;T> = T extends any ? T[] : never;\n\ntype StrArrOrNumArr = ToArray&#x3C;string | number>; // string[] | number[]\n</code></pre>\n<h2>映射类型 (Mapped Types)</h2>\n<p>映射类型可以基于现有类型创建新类型。</p>\n<h3>内置映射类型</h3>\n<pre><code class=\"language-typescript\">// Partial - 所有属性变为可选\ntype Partial&#x3C;T> = {\n  [P in keyof T]?: T[P];\n};\n\n// Required - 所有属性变为必需\ntype Required&#x3C;T> = {\n  [P in keyof T]-?: T[P];\n};\n\n// Readonly - 所有属性变为只读\ntype Readonly&#x3C;T> = {\n  readonly [P in keyof T]: T[P];\n};\n</code></pre>\n<h3>自定义映射类型</h3>\n<pre><code class=\"language-typescript\">// 为所有属性添加前缀\ntype Prefixed&#x3C;T, P extends string> = {\n  [K in keyof T as `${P}${string &#x26; K}`]: T[K];\n};\n\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype PrefixedUser = Prefixed&#x3C;User, 'user_'>;\n// { user_name: string; user_age: number; }\n</code></pre>\n<h2>模板字面量类型 (Template Literal Types)</h2>\n<p>TypeScript 4.1 引入了模板字面量类型，允许我们在类型层面操作字符串。</p>\n<h3>基础用法</h3>\n<pre><code class=\"language-typescript\">type World = \"world\";\ntype Greeting = `hello ${World}`; // \"hello world\"\n</code></pre>\n<h3>实际应用：事件系统</h3>\n<pre><code class=\"language-typescript\">type EventName&#x3C;T extends string> = `on${Capitalize&#x3C;T>}`;\n\ntype ButtonEvents = EventName&#x3C;'click' | 'hover' | 'focus'>;\n// 'onClick' | 'onHover' | 'onFocus'\n\n// 事件处理器类型\ntype EventHandlers&#x3C;T extends Record&#x3C;string, any>> = {\n  [K in keyof T as EventName&#x3C;string &#x26; K>]?: (event: T[K]) => void;\n};\n\ninterface Events {\n  click: MouseEvent;\n  hover: MouseEvent;\n  focus: FocusEvent;\n}\n\ntype Handlers = EventHandlers&#x3C;Events>;\n// {\n//   onClick?: (event: MouseEvent) => void;\n//   onHover?: (event: MouseEvent) => void;\n//   onFocus?: (event: FocusEvent) => void;\n// }\n</code></pre>\n<h2>工具类型组合</h2>\n<h3>深度只读类型</h3>\n<pre><code class=\"language-typescript\">type DeepReadonly&#x3C;T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly&#x3C;T[P]> : T[P];\n};\n\ninterface NestedObject {\n  user: {\n    profile: {\n      name: string;\n      settings: {\n        theme: string;\n      };\n    };\n  };\n}\n\ntype ReadonlyNested = DeepReadonly&#x3C;NestedObject>;\n// 所有嵌套属性都变为只读\n</code></pre>\n<h3>类型安全的路径访问</h3>\n<pre><code class=\"language-typescript\">type PathKeys&#x3C;T> = {\n  [K in keyof T]: T[K] extends object\n    ? K | `${string &#x26; K}.${PathKeys&#x3C;T[K]>}`\n    : K;\n}[keyof T];\n\ntype GetByPath&#x3C;T, P extends string> = P extends `${infer K}.${infer Rest}`\n  ? K extends keyof T\n    ? GetByPath&#x3C;T[K], Rest>\n    : never\n  : P extends keyof T\n  ? T[P]\n  : never;\n\ninterface Data {\n  user: {\n    profile: {\n      name: string;\n      age: number;\n    };\n    settings: {\n      theme: 'light' | 'dark';\n    };\n  };\n}\n\ntype ValidPaths = PathKeys&#x3C;Data>;\n// 'user' | 'user.profile' | 'user.profile.name' | 'user.profile.age' | 'user.settings' | 'user.settings.theme'\n\nfunction getValue&#x3C;T, P extends PathKeys&#x3C;T>>(obj: T, path: P): GetByPath&#x3C;T, P> {\n  // 实现省略\n  return null as any;\n}\n\nconst data: Data = { /* ... */ };\nconst name = getValue(data, 'user.profile.name'); // string\nconst theme = getValue(data, 'user.settings.theme'); // 'light' | 'dark'\n</code></pre>\n<h2>实际应用案例</h2>\n<h3>类型安全的 API 客户端</h3>\n<pre><code class=\"language-typescript\">// API 端点定义\ninterface ApiEndpoints {\n  '/users': {\n    GET: { response: User[] };\n    POST: { body: CreateUserRequest; response: User };\n  };\n  '/users/:id': {\n    GET: { params: { id: string }; response: User };\n    PUT: { params: { id: string }; body: UpdateUserRequest; response: User };\n    DELETE: { params: { id: string }; response: void };\n  };\n}\n\n// 提取方法类型\ntype Methods&#x3C;T> = T extends Record&#x3C;string, infer M> ? keyof M : never;\n\n// 提取请求参数类型\ntype RequestParams&#x3C;\n  T extends Record&#x3C;string, any>,\n  P extends keyof T,\n  M extends keyof T[P]\n> = T[P][M] extends { params: infer Params } ? Params : {};\n\n// 提取请求体类型\ntype RequestBody&#x3C;\n  T extends Record&#x3C;string, any>,\n  P extends keyof T,\n  M extends keyof T[P]\n> = T[P][M] extends { body: infer Body } ? Body : never;\n\n// 提取响应类型\ntype ResponseType&#x3C;\n  T extends Record&#x3C;string, any>,\n  P extends keyof T,\n  M extends keyof T[P]\n> = T[P][M] extends { response: infer Response } ? Response : never;\n\n// API 客户端类型\nclass ApiClient&#x3C;T extends Record&#x3C;string, any>> {\n  async request&#x3C;\n    P extends keyof T,\n    M extends Methods&#x3C;T[P]>\n  >(\n    path: P,\n    method: M,\n    ...args: RequestBody&#x3C;T, P, M> extends never\n      ? [params?: RequestParams&#x3C;T, P, M>]\n      : [params: RequestParams&#x3C;T, P, M>, body: RequestBody&#x3C;T, P, M>]\n  ): Promise&#x3C;ResponseType&#x3C;T, P, M>> {\n    // 实现省略\n    return null as any;\n  }\n}\n\n// 使用示例\nconst api = new ApiClient&#x3C;ApiEndpoints>();\n\n// 类型安全的 API 调用\nconst users = await api.request('/users', 'GET'); // User[]\nconst user = await api.request('/users/:id', 'GET', { id: '123' }); // User\nconst newUser = await api.request('/users', 'POST', {}, { name: 'John' }); // User\n</code></pre>\n<h3>表单验证类型</h3>\n<pre><code class=\"language-typescript\">// 验证规则类型\ntype ValidationRule&#x3C;T> = {\n  required?: boolean;\n  min?: T extends string ? number : T extends number ? number : never;\n  max?: T extends string ? number : T extends number ? number : never;\n  pattern?: T extends string ? RegExp : never;\n  custom?: (value: T) => boolean | string;\n};\n\n// 表单模式类型\ntype FormSchema&#x3C;T> = {\n  [K in keyof T]: ValidationRule&#x3C;T[K]>;\n};\n\n// 验证错误类型\ntype ValidationErrors&#x3C;T> = {\n  [K in keyof T]?: string[];\n};\n\n// 表单验证器\nclass FormValidator&#x3C;T extends Record&#x3C;string, any>> {\n  constructor(private schema: FormSchema&#x3C;T>) {}\n\n  validate(data: T): ValidationErrors&#x3C;T> {\n    const errors: ValidationErrors&#x3C;T> = {};\n\n    for (const key in this.schema) {\n      const rule = this.schema[key];\n      const value = data[key];\n      const fieldErrors: string[] = [];\n\n      if (rule.required &#x26;&#x26; !value) {\n        fieldErrors.push('This field is required');\n      }\n\n      if (value &#x26;&#x26; rule.min !== undefined) {\n        if (typeof value === 'string' &#x26;&#x26; value.length &#x3C; rule.min) {\n          fieldErrors.push(`Minimum length is ${rule.min}`);\n        }\n        if (typeof value === 'number' &#x26;&#x26; value &#x3C; rule.min) {\n          fieldErrors.push(`Minimum value is ${rule.min}`);\n        }\n      }\n\n      // 更多验证逻辑...\n\n      if (fieldErrors.length > 0) {\n        errors[key] = fieldErrors;\n      }\n    }\n\n    return errors;\n  }\n}\n\n// 使用示例\ninterface UserForm {\n  name: string;\n  email: string;\n  age: number;\n}\n\nconst validator = new FormValidator&#x3C;UserForm>({\n  name: { required: true, min: 2 },\n  email: { required: true, pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/ },\n  age: { required: true, min: 18, max: 120 }\n});\n\nconst errors = validator.validate({\n  name: 'John',\n  email: 'john@example.com',\n  age: 25\n});\n</code></pre>\n<h2>性能考虑</h2>\n<h3>避免过度复杂的类型</h3>\n<pre><code class=\"language-typescript\">// ❌ 过度复杂，可能导致编译性能问题\ntype OverlyComplex&#x3C;T> = T extends infer U\n  ? U extends Record&#x3C;string, any>\n    ? {\n        [K in keyof U]: U[K] extends infer V\n          ? V extends Record&#x3C;string, any>\n            ? OverlyComplex&#x3C;V>\n            : V\n          : never;\n      }\n    : U\n  : never;\n\n// ✅ 简化版本\ntype Simplified&#x3C;T> = T extends Record&#x3C;string, any>\n  ? { [K in keyof T]: Simplified&#x3C;T[K]> }\n  : T;\n</code></pre>\n<h3>使用类型断言优化</h3>\n<pre><code class=\"language-typescript\">// 在确保类型安全的前提下使用断言\nfunction processData&#x3C;T>(data: unknown): T {\n  // 运行时验证\n  if (isValidData(data)) {\n    return data as T;\n  }\n  throw new Error('Invalid data');\n}\n</code></pre>\n<h2>最佳实践</h2>\n<ol>\n<li><strong>渐进式采用</strong>: 从简单类型开始，逐步引入高级特性</li>\n<li><strong>文档化复杂类型</strong>: 为复杂的类型添加注释说明</li>\n<li><strong>测试类型</strong>: 使用类型测试确保类型行为正确</li>\n<li><strong>性能监控</strong>: 关注编译时间，避免过度复杂的类型</li>\n</ol>\n<pre><code class=\"language-typescript\">// 类型测试示例\ntype Expect&#x3C;T extends true> = T;\ntype Equal&#x3C;X, Y> = (&#x3C;T>() => T extends X ? 1 : 2) extends &#x3C;T>() => T extends Y ? 1 : 2 ? true : false;\n\n// 测试用例\ntype Test1 = Expect&#x3C;Equal&#x3C;ConditionalType&#x3C;string>, string>>;\ntype Test2 = Expect&#x3C;Equal&#x3C;ConditionalType&#x3C;number>, number>>;\n</code></pre>\n<h2>总结</h2>\n<p>TypeScript 的高级类型系统为我们提供了强大的工具来构建类型安全的应用：</p>\n<ul>\n<li><strong>条件类型</strong>: 根据条件选择类型</li>\n<li><strong>映射类型</strong>: 转换现有类型</li>\n<li><strong>模板字面量类型</strong>: 类型层面的字符串操作</li>\n<li><strong>工具类型组合</strong>: 构建复杂的类型逻辑</li>\n</ul>\n<p>掌握这些高级特性，能让我们的 TypeScript 代码更加健壮和可维护。记住，类型系统的目标是帮助我们写出更好的代码，而不是增加复杂性。在实际项目中，要根据需求合理使用这些特性。</p>"
    },
    "_id": "articles/typescript-advanced-types.md",
    "_raw": {
      "sourceFilePath": "articles/typescript-advanced-types.md",
      "sourceFileName": "typescript-advanced-types.md",
      "sourceFileDir": "articles",
      "contentType": "markdown",
      "flattenedPath": "articles/typescript-advanced-types"
    },
    "type": "Article",
    "slug": "typescript-advanced-types",
    "readingTime": {
      "text": "9 min read",
      "minutes": 8.775,
      "time": 526500,
      "words": 1755
    },
    "url": "/articles/typescript-advanced-types"
  }
]