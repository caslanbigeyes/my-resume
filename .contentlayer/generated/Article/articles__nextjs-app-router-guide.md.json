{
  "title": "Next.js App Router 完全指南",
  "excerpt": "全面介绍 Next.js 14 的 App Router，包括路由系统、布局、加载状态、错误处理等核心概念和最佳实践。",
  "publishedAt": "2024-02-01T00:00:00.000Z",
  "author": "hero",
  "category": "frontend",
  "tags": [
    "nextjs",
    "react",
    "typescript"
  ],
  "featured": true,
  "published": true,
  "image": "/images/articles/nextjs-app-router.jpg",
  "seoTitle": "Next.js App Router 完全指南 - 掌握新一代路由系统",
  "seoDescription": "学习 Next.js 14 App Router 的核心概念和最佳实践，包括文件系统路由、布局、服务器组件等",
  "seoKeywords": [
    "Next.js",
    "App Router",
    "React Server Components",
    "文件系统路由"
  ],
  "body": {
    "raw": "\n# Next.js App Router 完全指南\n\nNext.js 13 引入了全新的 App Router，这是基于 React Server Components 构建的下一代路由系统。本文将全面介绍 App Router 的核心概念和最佳实践。\n\n## App Router vs Pages Router\n\n### Pages Router (传统方式)\n```\npages/\n├── index.js          // /\n├── about.js          // /about\n└── blog/\n    ├── index.js      // /blog\n    └── [slug].js     // /blog/[slug]\n```\n\n### App Router (新方式)\n```\napp/\n├── page.tsx          // /\n├── about/\n│   └── page.tsx      // /about\n└── blog/\n    ├── page.tsx      // /blog\n    └── [slug]/\n        └── page.tsx  // /blog/[slug]\n```\n\n## 核心概念\n\n### 1. 文件约定\n\nApp Router 使用特殊的文件名来定义路由行为：\n\n- `page.tsx`: 定义路由页面\n- `layout.tsx`: 定义布局\n- `loading.tsx`: 定义加载状态\n- `error.tsx`: 定义错误页面\n- `not-found.tsx`: 定义 404 页面\n- `route.tsx`: 定义 API 路由\n\n### 2. 布局系统\n\n#### 根布局 (必需)\n\n```tsx\n// app/layout.tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"zh\">\n      <body>\n        <header>\n          <nav>全局导航</nav>\n        </header>\n        <main>{children}</main>\n        <footer>全局页脚</footer>\n      </body>\n    </html>\n  );\n}\n```\n\n#### 嵌套布局\n\n```tsx\n// app/blog/layout.tsx\nexport default function BlogLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <div className=\"blog-container\">\n      <aside>\n        <h2>博客侧边栏</h2>\n        <nav>博客导航</nav>\n      </aside>\n      <div className=\"blog-content\">\n        {children}\n      </div>\n    </div>\n  );\n}\n```\n\n### 3. 页面组件\n\n```tsx\n// app/blog/page.tsx\nexport default function BlogPage() {\n  return (\n    <div>\n      <h1>博客首页</h1>\n      <p>欢迎来到我的博客</p>\n    </div>\n  );\n}\n```\n\n### 4. 动态路由\n\n#### 单个动态段\n\n```tsx\n// app/blog/[slug]/page.tsx\nexport default function BlogPost({\n  params,\n}: {\n  params: { slug: string };\n}) {\n  return (\n    <div>\n      <h1>文章: {params.slug}</h1>\n    </div>\n  );\n}\n```\n\n#### 多个动态段\n\n```tsx\n// app/blog/[category]/[slug]/page.tsx\nexport default function CategoryPost({\n  params,\n}: {\n  params: { category: string; slug: string };\n}) {\n  return (\n    <div>\n      <h1>分类: {params.category}</h1>\n      <h2>文章: {params.slug}</h2>\n    </div>\n  );\n}\n```\n\n#### 捕获所有路由\n\n```tsx\n// app/docs/[...slug]/page.tsx\nexport default function DocsPage({\n  params,\n}: {\n  params: { slug: string[] };\n}) {\n  return (\n    <div>\n      <h1>文档路径: {params.slug.join('/')}</h1>\n    </div>\n  );\n}\n```\n\n## 服务器组件 vs 客户端组件\n\n### 服务器组件 (默认)\n\n```tsx\n// 这是一个服务器组件\nasync function BlogPost({ params }: { params: { slug: string } }) {\n  // 可以直接在服务器端获取数据\n  const post = await getPost(params.slug);\n\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </article>\n  );\n}\n```\n\n### 客户端组件\n\n```tsx\n'use client'; // 标记为客户端组件\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>计数: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        增加\n      </button>\n    </div>\n  );\n}\n```\n\n## 数据获取\n\n### 服务器端数据获取\n\n```tsx\n// app/posts/page.tsx\nasync function getPosts() {\n  const res = await fetch('https://api.example.com/posts', {\n    // 可以配置缓存策略\n    next: { revalidate: 3600 } // 1小时后重新验证\n  });\n\n  if (!res.ok) {\n    throw new Error('Failed to fetch posts');\n  }\n\n  return res.json();\n}\n\nexport default async function PostsPage() {\n  const posts = await getPosts();\n\n  return (\n    <div>\n      <h1>文章列表</h1>\n      {posts.map((post: any) => (\n        <div key={post.id}>\n          <h2>{post.title}</h2>\n          <p>{post.excerpt}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n### 并行数据获取\n\n```tsx\nasync function getUser(id: string) {\n  const res = await fetch(`/api/users/${id}`);\n  return res.json();\n}\n\nasync function getUserPosts(id: string) {\n  const res = await fetch(`/api/users/${id}/posts`);\n  return res.json();\n}\n\nexport default async function UserProfile({\n  params,\n}: {\n  params: { id: string };\n}) {\n  // 并行获取数据\n  const [user, posts] = await Promise.all([\n    getUser(params.id),\n    getUserPosts(params.id),\n  ]);\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <div>\n        <h2>用户文章</h2>\n        {posts.map((post: any) => (\n          <div key={post.id}>{post.title}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\n## 加载状态\n\n```tsx\n// app/blog/loading.tsx\nexport default function Loading() {\n  return (\n    <div className=\"loading-container\">\n      <div className=\"spinner\"></div>\n      <p>加载中...</p>\n    </div>\n  );\n}\n```\n\n## 错误处理\n\n```tsx\n// app/blog/error.tsx\n'use client';\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string };\n  reset: () => void;\n}) {\n  return (\n    <div className=\"error-container\">\n      <h2>出错了！</h2>\n      <p>{error.message}</p>\n      <button onClick={reset}>重试</button>\n    </div>\n  );\n}\n```\n\n## 路由组\n\n使用括号创建路由组，不影响 URL 结构：\n\n```\napp/\n├── (marketing)/\n│   ├── about/\n│   │   └── page.tsx     // /about\n│   └── contact/\n│       └── page.tsx     // /contact\n└── (shop)/\n    ├── products/\n    │   └── page.tsx     // /products\n    └── cart/\n        └── page.tsx     // /cart\n```\n\n每个路由组可以有自己的布局：\n\n```tsx\n// app/(marketing)/layout.tsx\nexport default function MarketingLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <div className=\"marketing-layout\">\n      <nav>营销页面导航</nav>\n      {children}\n    </div>\n  );\n}\n```\n\n## 拦截路由\n\n使用 `(..)` 语法拦截路由：\n\n```\napp/\n├── feed/\n│   └── page.tsx\n├── photo/\n│   └── [id]/\n│       └── page.tsx\n└── @modal/\n    └── (..)photo/\n        └── [id]/\n            └── page.tsx\n```\n\n## 并行路由\n\n使用 `@` 语法创建并行路由：\n\n```tsx\n// app/layout.tsx\nexport default function Layout({\n  children,\n  analytics,\n  team,\n}: {\n  children: React.ReactNode;\n  analytics: React.ReactNode;\n  team: React.ReactNode;\n}) {\n  return (\n    <>\n      {children}\n      {analytics}\n      {team}\n    </>\n  );\n}\n```\n\n## 最佳实践\n\n### 1. 合理使用服务器组件和客户端组件\n\n```tsx\n// 服务器组件负责数据获取\nasync function PostList() {\n  const posts = await getPosts();\n\n  return (\n    <div>\n      {posts.map(post => (\n        <PostCard key={post.id} post={post} />\n      ))}\n    </div>\n  );\n}\n\n// 客户端组件负责交互\n'use client';\nfunction PostCard({ post }) {\n  const [liked, setLiked] = useState(false);\n\n  return (\n    <div>\n      <h3>{post.title}</h3>\n      <button onClick={() => setLiked(!liked)}>\n        {liked ? '❤️' : '🤍'}\n      </button>\n    </div>\n  );\n}\n```\n\n### 2. 优化数据获取\n\n```tsx\n// 使用适当的缓存策略\nasync function getData() {\n  const res = await fetch('https://api.example.com/data', {\n    next: {\n      revalidate: 3600, // 静态重新生成\n      tags: ['posts'] // 标签重新验证\n    }\n  });\n\n  return res.json();\n}\n```\n\n### 3. 错误边界和加载状态\n\n为每个路由段提供适当的错误处理和加载状态：\n\n```\napp/\n├── dashboard/\n│   ├── loading.tsx      // 仪表板加载状态\n│   ├── error.tsx        // 仪表板错误处理\n│   ├── page.tsx\n│   └── analytics/\n│       ├── loading.tsx  // 分析页面加载状态\n│       ├── error.tsx    // 分析页面错误处理\n│       └── page.tsx\n```\n\n## 总结\n\nNext.js App Router 带来了许多强大的特性：\n\n- **基于文件系统的路由**: 直观的路由结构\n- **布局系统**: 灵活的嵌套布局\n- **服务器组件**: 更好的性能和 SEO\n- **流式渲染**: 改善用户体验\n- **并行路由**: 复杂 UI 的解决方案\n\nApp Router 代表了 React 和 Next.js 的未来方向，值得我们深入学习和实践。\n",
    "html": "<h1>Next.js App Router 完全指南</h1>\n<p>Next.js 13 引入了全新的 App Router，这是基于 React Server Components 构建的下一代路由系统。本文将全面介绍 App Router 的核心概念和最佳实践。</p>\n<h2>App Router vs Pages Router</h2>\n<h3>Pages Router (传统方式)</h3>\n<pre><code>pages/\n├── index.js          // /\n├── about.js          // /about\n└── blog/\n    ├── index.js      // /blog\n    └── [slug].js     // /blog/[slug]\n</code></pre>\n<h3>App Router (新方式)</h3>\n<pre><code>app/\n├── page.tsx          // /\n├── about/\n│   └── page.tsx      // /about\n└── blog/\n    ├── page.tsx      // /blog\n    └── [slug]/\n        └── page.tsx  // /blog/[slug]\n</code></pre>\n<h2>核心概念</h2>\n<h3>1. 文件约定</h3>\n<p>App Router 使用特殊的文件名来定义路由行为：</p>\n<ul>\n<li><code>page.tsx</code>: 定义路由页面</li>\n<li><code>layout.tsx</code>: 定义布局</li>\n<li><code>loading.tsx</code>: 定义加载状态</li>\n<li><code>error.tsx</code>: 定义错误页面</li>\n<li><code>not-found.tsx</code>: 定义 404 页面</li>\n<li><code>route.tsx</code>: 定义 API 路由</li>\n</ul>\n<h3>2. 布局系统</h3>\n<h4>根布局 (必需)</h4>\n<pre><code class=\"language-tsx\">// app/layout.tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &#x3C;html lang=\"zh\">\n      &#x3C;body>\n        &#x3C;header>\n          &#x3C;nav>全局导航&#x3C;/nav>\n        &#x3C;/header>\n        &#x3C;main>{children}&#x3C;/main>\n        &#x3C;footer>全局页脚&#x3C;/footer>\n      &#x3C;/body>\n    &#x3C;/html>\n  );\n}\n</code></pre>\n<h4>嵌套布局</h4>\n<pre><code class=\"language-tsx\">// app/blog/layout.tsx\nexport default function BlogLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &#x3C;div className=\"blog-container\">\n      &#x3C;aside>\n        &#x3C;h2>博客侧边栏&#x3C;/h2>\n        &#x3C;nav>博客导航&#x3C;/nav>\n      &#x3C;/aside>\n      &#x3C;div className=\"blog-content\">\n        {children}\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>3. 页面组件</h3>\n<pre><code class=\"language-tsx\">// app/blog/page.tsx\nexport default function BlogPage() {\n  return (\n    &#x3C;div>\n      &#x3C;h1>博客首页&#x3C;/h1>\n      &#x3C;p>欢迎来到我的博客&#x3C;/p>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>4. 动态路由</h3>\n<h4>单个动态段</h4>\n<pre><code class=\"language-tsx\">// app/blog/[slug]/page.tsx\nexport default function BlogPost({\n  params,\n}: {\n  params: { slug: string };\n}) {\n  return (\n    &#x3C;div>\n      &#x3C;h1>文章: {params.slug}&#x3C;/h1>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h4>多个动态段</h4>\n<pre><code class=\"language-tsx\">// app/blog/[category]/[slug]/page.tsx\nexport default function CategoryPost({\n  params,\n}: {\n  params: { category: string; slug: string };\n}) {\n  return (\n    &#x3C;div>\n      &#x3C;h1>分类: {params.category}&#x3C;/h1>\n      &#x3C;h2>文章: {params.slug}&#x3C;/h2>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h4>捕获所有路由</h4>\n<pre><code class=\"language-tsx\">// app/docs/[...slug]/page.tsx\nexport default function DocsPage({\n  params,\n}: {\n  params: { slug: string[] };\n}) {\n  return (\n    &#x3C;div>\n      &#x3C;h1>文档路径: {params.slug.join('/')}&#x3C;/h1>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>服务器组件 vs 客户端组件</h2>\n<h3>服务器组件 (默认)</h3>\n<pre><code class=\"language-tsx\">// 这是一个服务器组件\nasync function BlogPost({ params }: { params: { slug: string } }) {\n  // 可以直接在服务器端获取数据\n  const post = await getPost(params.slug);\n\n  return (\n    &#x3C;article>\n      &#x3C;h1>{post.title}&#x3C;/h1>\n      &#x3C;p>{post.content}&#x3C;/p>\n    &#x3C;/article>\n  );\n}\n</code></pre>\n<h3>客户端组件</h3>\n<pre><code class=\"language-tsx\">'use client'; // 标记为客户端组件\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &#x3C;div>\n      &#x3C;p>计数: {count}&#x3C;/p>\n      &#x3C;button onClick={() => setCount(count + 1)}>\n        增加\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>数据获取</h2>\n<h3>服务器端数据获取</h3>\n<pre><code class=\"language-tsx\">// app/posts/page.tsx\nasync function getPosts() {\n  const res = await fetch('https://api.example.com/posts', {\n    // 可以配置缓存策略\n    next: { revalidate: 3600 } // 1小时后重新验证\n  });\n\n  if (!res.ok) {\n    throw new Error('Failed to fetch posts');\n  }\n\n  return res.json();\n}\n\nexport default async function PostsPage() {\n  const posts = await getPosts();\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>文章列表&#x3C;/h1>\n      {posts.map((post: any) => (\n        &#x3C;div key={post.id}>\n          &#x3C;h2>{post.title}&#x3C;/h2>\n          &#x3C;p>{post.excerpt}&#x3C;/p>\n        &#x3C;/div>\n      ))}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>并行数据获取</h3>\n<pre><code class=\"language-tsx\">async function getUser(id: string) {\n  const res = await fetch(`/api/users/${id}`);\n  return res.json();\n}\n\nasync function getUserPosts(id: string) {\n  const res = await fetch(`/api/users/${id}/posts`);\n  return res.json();\n}\n\nexport default async function UserProfile({\n  params,\n}: {\n  params: { id: string };\n}) {\n  // 并行获取数据\n  const [user, posts] = await Promise.all([\n    getUser(params.id),\n    getUserPosts(params.id),\n  ]);\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>{user.name}&#x3C;/h1>\n      &#x3C;div>\n        &#x3C;h2>用户文章&#x3C;/h2>\n        {posts.map((post: any) => (\n          &#x3C;div key={post.id}>{post.title}&#x3C;/div>\n        ))}\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>加载状态</h2>\n<pre><code class=\"language-tsx\">// app/blog/loading.tsx\nexport default function Loading() {\n  return (\n    &#x3C;div className=\"loading-container\">\n      &#x3C;div className=\"spinner\">&#x3C;/div>\n      &#x3C;p>加载中...&#x3C;/p>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>错误处理</h2>\n<pre><code class=\"language-tsx\">// app/blog/error.tsx\n'use client';\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error &#x26; { digest?: string };\n  reset: () => void;\n}) {\n  return (\n    &#x3C;div className=\"error-container\">\n      &#x3C;h2>出错了！&#x3C;/h2>\n      &#x3C;p>{error.message}&#x3C;/p>\n      &#x3C;button onClick={reset}>重试&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>路由组</h2>\n<p>使用括号创建路由组，不影响 URL 结构：</p>\n<pre><code>app/\n├── (marketing)/\n│   ├── about/\n│   │   └── page.tsx     // /about\n│   └── contact/\n│       └── page.tsx     // /contact\n└── (shop)/\n    ├── products/\n    │   └── page.tsx     // /products\n    └── cart/\n        └── page.tsx     // /cart\n</code></pre>\n<p>每个路由组可以有自己的布局：</p>\n<pre><code class=\"language-tsx\">// app/(marketing)/layout.tsx\nexport default function MarketingLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    &#x3C;div className=\"marketing-layout\">\n      &#x3C;nav>营销页面导航&#x3C;/nav>\n      {children}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>拦截路由</h2>\n<p>使用 <code>(..)</code> 语法拦截路由：</p>\n<pre><code>app/\n├── feed/\n│   └── page.tsx\n├── photo/\n│   └── [id]/\n│       └── page.tsx\n└── @modal/\n    └── (..)photo/\n        └── [id]/\n            └── page.tsx\n</code></pre>\n<h2>并行路由</h2>\n<p>使用 <code>@</code> 语法创建并行路由：</p>\n<pre><code class=\"language-tsx\">// app/layout.tsx\nexport default function Layout({\n  children,\n  analytics,\n  team,\n}: {\n  children: React.ReactNode;\n  analytics: React.ReactNode;\n  team: React.ReactNode;\n}) {\n  return (\n    &#x3C;>\n      {children}\n      {analytics}\n      {team}\n    &#x3C;/>\n  );\n}\n</code></pre>\n<h2>最佳实践</h2>\n<h3>1. 合理使用服务器组件和客户端组件</h3>\n<pre><code class=\"language-tsx\">// 服务器组件负责数据获取\nasync function PostList() {\n  const posts = await getPosts();\n\n  return (\n    &#x3C;div>\n      {posts.map(post => (\n        &#x3C;PostCard key={post.id} post={post} />\n      ))}\n    &#x3C;/div>\n  );\n}\n\n// 客户端组件负责交互\n'use client';\nfunction PostCard({ post }) {\n  const [liked, setLiked] = useState(false);\n\n  return (\n    &#x3C;div>\n      &#x3C;h3>{post.title}&#x3C;/h3>\n      &#x3C;button onClick={() => setLiked(!liked)}>\n        {liked ? '❤️' : '🤍'}\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>2. 优化数据获取</h3>\n<pre><code class=\"language-tsx\">// 使用适当的缓存策略\nasync function getData() {\n  const res = await fetch('https://api.example.com/data', {\n    next: {\n      revalidate: 3600, // 静态重新生成\n      tags: ['posts'] // 标签重新验证\n    }\n  });\n\n  return res.json();\n}\n</code></pre>\n<h3>3. 错误边界和加载状态</h3>\n<p>为每个路由段提供适当的错误处理和加载状态：</p>\n<pre><code>app/\n├── dashboard/\n│   ├── loading.tsx      // 仪表板加载状态\n│   ├── error.tsx        // 仪表板错误处理\n│   ├── page.tsx\n│   └── analytics/\n│       ├── loading.tsx  // 分析页面加载状态\n│       ├── error.tsx    // 分析页面错误处理\n│       └── page.tsx\n</code></pre>\n<h2>总结</h2>\n<p>Next.js App Router 带来了许多强大的特性：</p>\n<ul>\n<li><strong>基于文件系统的路由</strong>: 直观的路由结构</li>\n<li><strong>布局系统</strong>: 灵活的嵌套布局</li>\n<li><strong>服务器组件</strong>: 更好的性能和 SEO</li>\n<li><strong>流式渲染</strong>: 改善用户体验</li>\n<li><strong>并行路由</strong>: 复杂 UI 的解决方案</li>\n</ul>\n<p>App Router 代表了 React 和 Next.js 的未来方向，值得我们深入学习和实践。</p>"
  },
  "_id": "articles/nextjs-app-router-guide.md",
  "_raw": {
    "sourceFilePath": "articles/nextjs-app-router-guide.md",
    "sourceFileName": "nextjs-app-router-guide.md",
    "sourceFileDir": "articles",
    "contentType": "markdown",
    "flattenedPath": "articles/nextjs-app-router-guide"
  },
  "type": "Article",
  "slug": "nextjs-app-router-guide",
  "readingTime": {
    "text": "7 min read",
    "minutes": 6.71,
    "time": 402600,
    "words": 1342
  },
  "url": "/articles/nextjs-app-router-guide"
}