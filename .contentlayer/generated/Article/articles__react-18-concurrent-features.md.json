{
  "title": "React 18 并发特性深度解析",
  "excerpt": "深入探讨 React 18 的并发渲染机制，包括 useTransition、useDeferredValue 等新 Hook 的使用场景和最佳实践。",
  "publishedAt": "2024-01-15T00:00:00.000Z",
  "updatedAt": "2024-01-20T00:00:00.000Z",
  "author": "li-lingfeng",
  "category": "frontend",
  "tags": [
    "react",
    "typescript"
  ],
  "featured": true,
  "published": true,
  "image": "/images/articles/react-18-concurrent.jpg",
  "seoTitle": "React 18 并发特性深度解析 - 提升应用性能的新方法",
  "seoDescription": "学习 React 18 的并发特性，掌握 useTransition、useDeferredValue 等新 Hook，提升应用性能和用户体验",
  "seoKeywords": [
    "React 18",
    "并发渲染",
    "useTransition",
    "useDeferredValue",
    "性能优化"
  ],
  "body": {
    "raw": "\n# React 18 并发特性深度解析\n\nReact 18 引入了期待已久的并发特性，这些特性让我们能够构建更加流畅和响应式的用户界面。本文将深入探讨这些新特性的工作原理和实际应用。\n\n## 什么是并发渲染？\n\n并发渲染是 React 18 的核心特性，它允许 React 在渲染过程中暂停和恢复工作。这意味着：\n\n- React 可以同时准备多个版本的 UI\n- 高优先级的更新可以中断低优先级的更新\n- 用户界面保持响应，即使在处理大量计算时\n\n## useTransition Hook\n\n`useTransition` 是 React 18 中最重要的新 Hook 之一，它允许我们将状态更新标记为非紧急的。\n\n### 基本用法\n\n```jsx\nimport { useState, useTransition } from 'react';\n\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSearch = (newQuery) => {\n    setQuery(newQuery); // 紧急更新\n\n    startTransition(() => {\n      // 非紧急更新\n      setResults(searchData(newQuery));\n    });\n  };\n\n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => handleSearch(e.target.value)}\n        placeholder=\"搜索...\"\n      />\n\n      {isPending && <div>搜索中...</div>}\n\n      <SearchResultsList results={results} />\n    </div>\n  );\n}\n```\n\n### 实际应用场景\n\n1. **搜索功能**: 输入框的更新是紧急的，搜索结果的更新可以延迟\n2. **标签页切换**: 标签的激活状态是紧急的，内容加载可以延迟\n3. **数据过滤**: 过滤条件的更新是紧急的，结果渲染可以延迟\n\n## useDeferredValue Hook\n\n`useDeferredValue` 允许我们延迟更新 UI 的某些部分，直到更紧急的更新完成。\n\n### 基本用法\n\n```jsx\nimport { useState, useDeferredValue, useMemo } from 'react';\n\nfunction ProductList({ searchQuery }) {\n  const deferredQuery = useDeferredValue(searchQuery);\n\n  const filteredProducts = useMemo(() => {\n    return products.filter(product =>\n      product.name.toLowerCase().includes(deferredQuery.toLowerCase())\n    );\n  }, [deferredQuery]);\n\n  return (\n    <div>\n      {filteredProducts.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  );\n}\n```\n\n### 与 useTransition 的区别\n\n- `useTransition`: 控制状态更新的优先级\n- `useDeferredValue`: 延迟值的更新，通常用于昂贵的计算\n\n## Suspense 的改进\n\nReact 18 中的 Suspense 不仅支持代码分割，还支持数据获取：\n\n```jsx\nfunction App() {\n  return (\n    <Suspense fallback={<GlobalSpinner />}>\n      <Header />\n      <Suspense fallback={<SidebarSkeleton />}>\n        <Sidebar />\n      </Suspense>\n      <Suspense fallback={<ContentSkeleton />}>\n        <MainContent />\n      </Suspense>\n    </Suspense>\n  );\n}\n```\n\n## 自动批处理\n\nReact 18 自动批处理所有状态更新，包括在 Promise、setTimeout 和原生事件处理器中的更新：\n\n```jsx\n// React 18 中，这些更新会被自动批处理\nfunction handleClick() {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // React 只会重新渲染一次\n}\n\n// 如果需要退出批处理，可以使用 flushSync\nimport { flushSync } from 'react-dom';\n\nfunction handleClick() {\n  flushSync(() => {\n    setCount(c => c + 1);\n  });\n  // React 已经重新渲染了\n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React 再次重新渲染了\n}\n```\n\n## 最佳实践\n\n### 1. 识别紧急和非紧急更新\n\n```jsx\n// 紧急：用户输入、悬停、点击\nconst handleInputChange = (value) => {\n  setValue(value); // 紧急更新\n\n  startTransition(() => {\n    setSearchResults(search(value)); // 非紧急更新\n  });\n};\n```\n\n### 2. 使用 useMemo 优化昂贵计算\n\n```jsx\nconst ExpensiveComponent = ({ data }) => {\n  const deferredData = useDeferredValue(data);\n\n  const expensiveValue = useMemo(() => {\n    return performExpensiveCalculation(deferredData);\n  }, [deferredData]);\n\n  return <div>{expensiveValue}</div>;\n};\n```\n\n### 3. 合理使用 Suspense 边界\n\n```jsx\n// 为不同的 UI 部分设置不同的 Suspense 边界\nfunction Dashboard() {\n  return (\n    <div>\n      <Suspense fallback={<HeaderSkeleton />}>\n        <Header />\n      </Suspense>\n\n      <div className=\"main-content\">\n        <Suspense fallback={<SidebarSkeleton />}>\n          <Sidebar />\n        </Suspense>\n\n        <Suspense fallback={<ContentSkeleton />}>\n          <MainContent />\n        </Suspense>\n      </div>\n    </div>\n  );\n}\n```\n\n## 性能监控\n\n使用 React DevTools Profiler 来监控并发特性的效果：\n\n```jsx\nimport { Profiler } from 'react';\n\nfunction onRenderCallback(id, phase, actualDuration) {\n  console.log('Component:', id);\n  console.log('Phase:', phase);\n  console.log('Duration:', actualDuration);\n}\n\nfunction App() {\n  return (\n    <Profiler id=\"App\" onRender={onRenderCallback}>\n      <MyComponent />\n    </Profiler>\n  );\n}\n```\n\n## 总结\n\nReact 18 的并发特性为我们提供了强大的工具来构建更加流畅的用户界面：\n\n- **useTransition**: 标记非紧急更新，保持界面响应\n- **useDeferredValue**: 延迟昂贵计算，优化性能\n- **改进的 Suspense**: 更好的加载状态管理\n- **自动批处理**: 减少不必要的重新渲染\n\n这些特性需要我们重新思考应用的状态管理和更新策略。通过合理使用这些工具，我们可以显著提升应用的性能和用户体验。\n\n记住，并发特性是渐进式的增强，你可以逐步在现有应用中采用这些特性，而不需要大规模重构。\n",
    "html": "<h1>React 18 并发特性深度解析</h1>\n<p>React 18 引入了期待已久的并发特性，这些特性让我们能够构建更加流畅和响应式的用户界面。本文将深入探讨这些新特性的工作原理和实际应用。</p>\n<h2>什么是并发渲染？</h2>\n<p>并发渲染是 React 18 的核心特性，它允许 React 在渲染过程中暂停和恢复工作。这意味着：</p>\n<ul>\n<li>React 可以同时准备多个版本的 UI</li>\n<li>高优先级的更新可以中断低优先级的更新</li>\n<li>用户界面保持响应，即使在处理大量计算时</li>\n</ul>\n<h2>useTransition Hook</h2>\n<p><code>useTransition</code> 是 React 18 中最重要的新 Hook 之一，它允许我们将状态更新标记为非紧急的。</p>\n<h3>基本用法</h3>\n<pre><code class=\"language-jsx\">import { useState, useTransition } from 'react';\n\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSearch = (newQuery) => {\n    setQuery(newQuery); // 紧急更新\n\n    startTransition(() => {\n      // 非紧急更新\n      setResults(searchData(newQuery));\n    });\n  };\n\n  return (\n    &#x3C;div>\n      &#x3C;input\n        value={query}\n        onChange={(e) => handleSearch(e.target.value)}\n        placeholder=\"搜索...\"\n      />\n\n      {isPending &#x26;&#x26; &#x3C;div>搜索中...&#x3C;/div>}\n\n      &#x3C;SearchResultsList results={results} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>实际应用场景</h3>\n<ol>\n<li><strong>搜索功能</strong>: 输入框的更新是紧急的，搜索结果的更新可以延迟</li>\n<li><strong>标签页切换</strong>: 标签的激活状态是紧急的，内容加载可以延迟</li>\n<li><strong>数据过滤</strong>: 过滤条件的更新是紧急的，结果渲染可以延迟</li>\n</ol>\n<h2>useDeferredValue Hook</h2>\n<p><code>useDeferredValue</code> 允许我们延迟更新 UI 的某些部分，直到更紧急的更新完成。</p>\n<h3>基本用法</h3>\n<pre><code class=\"language-jsx\">import { useState, useDeferredValue, useMemo } from 'react';\n\nfunction ProductList({ searchQuery }) {\n  const deferredQuery = useDeferredValue(searchQuery);\n\n  const filteredProducts = useMemo(() => {\n    return products.filter(product =>\n      product.name.toLowerCase().includes(deferredQuery.toLowerCase())\n    );\n  }, [deferredQuery]);\n\n  return (\n    &#x3C;div>\n      {filteredProducts.map(product => (\n        &#x3C;ProductCard key={product.id} product={product} />\n      ))}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>与 useTransition 的区别</h3>\n<ul>\n<li><code>useTransition</code>: 控制状态更新的优先级</li>\n<li><code>useDeferredValue</code>: 延迟值的更新，通常用于昂贵的计算</li>\n</ul>\n<h2>Suspense 的改进</h2>\n<p>React 18 中的 Suspense 不仅支持代码分割，还支持数据获取：</p>\n<pre><code class=\"language-jsx\">function App() {\n  return (\n    &#x3C;Suspense fallback={&#x3C;GlobalSpinner />}>\n      &#x3C;Header />\n      &#x3C;Suspense fallback={&#x3C;SidebarSkeleton />}>\n        &#x3C;Sidebar />\n      &#x3C;/Suspense>\n      &#x3C;Suspense fallback={&#x3C;ContentSkeleton />}>\n        &#x3C;MainContent />\n      &#x3C;/Suspense>\n    &#x3C;/Suspense>\n  );\n}\n</code></pre>\n<h2>自动批处理</h2>\n<p>React 18 自动批处理所有状态更新，包括在 Promise、setTimeout 和原生事件处理器中的更新：</p>\n<pre><code class=\"language-jsx\">// React 18 中，这些更新会被自动批处理\nfunction handleClick() {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // React 只会重新渲染一次\n}\n\n// 如果需要退出批处理，可以使用 flushSync\nimport { flushSync } from 'react-dom';\n\nfunction handleClick() {\n  flushSync(() => {\n    setCount(c => c + 1);\n  });\n  // React 已经重新渲染了\n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React 再次重新渲染了\n}\n</code></pre>\n<h2>最佳实践</h2>\n<h3>1. 识别紧急和非紧急更新</h3>\n<pre><code class=\"language-jsx\">// 紧急：用户输入、悬停、点击\nconst handleInputChange = (value) => {\n  setValue(value); // 紧急更新\n\n  startTransition(() => {\n    setSearchResults(search(value)); // 非紧急更新\n  });\n};\n</code></pre>\n<h3>2. 使用 useMemo 优化昂贵计算</h3>\n<pre><code class=\"language-jsx\">const ExpensiveComponent = ({ data }) => {\n  const deferredData = useDeferredValue(data);\n\n  const expensiveValue = useMemo(() => {\n    return performExpensiveCalculation(deferredData);\n  }, [deferredData]);\n\n  return &#x3C;div>{expensiveValue}&#x3C;/div>;\n};\n</code></pre>\n<h3>3. 合理使用 Suspense 边界</h3>\n<pre><code class=\"language-jsx\">// 为不同的 UI 部分设置不同的 Suspense 边界\nfunction Dashboard() {\n  return (\n    &#x3C;div>\n      &#x3C;Suspense fallback={&#x3C;HeaderSkeleton />}>\n        &#x3C;Header />\n      &#x3C;/Suspense>\n\n      &#x3C;div className=\"main-content\">\n        &#x3C;Suspense fallback={&#x3C;SidebarSkeleton />}>\n          &#x3C;Sidebar />\n        &#x3C;/Suspense>\n\n        &#x3C;Suspense fallback={&#x3C;ContentSkeleton />}>\n          &#x3C;MainContent />\n        &#x3C;/Suspense>\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>性能监控</h2>\n<p>使用 React DevTools Profiler 来监控并发特性的效果：</p>\n<pre><code class=\"language-jsx\">import { Profiler } from 'react';\n\nfunction onRenderCallback(id, phase, actualDuration) {\n  console.log('Component:', id);\n  console.log('Phase:', phase);\n  console.log('Duration:', actualDuration);\n}\n\nfunction App() {\n  return (\n    &#x3C;Profiler id=\"App\" onRender={onRenderCallback}>\n      &#x3C;MyComponent />\n    &#x3C;/Profiler>\n  );\n}\n</code></pre>\n<h2>总结</h2>\n<p>React 18 的并发特性为我们提供了强大的工具来构建更加流畅的用户界面：</p>\n<ul>\n<li><strong>useTransition</strong>: 标记非紧急更新，保持界面响应</li>\n<li><strong>useDeferredValue</strong>: 延迟昂贵计算，优化性能</li>\n<li><strong>改进的 Suspense</strong>: 更好的加载状态管理</li>\n<li><strong>自动批处理</strong>: 减少不必要的重新渲染</li>\n</ul>\n<p>这些特性需要我们重新思考应用的状态管理和更新策略。通过合理使用这些工具，我们可以显著提升应用的性能和用户体验。</p>\n<p>记住，并发特性是渐进式的增强，你可以逐步在现有应用中采用这些特性，而不需要大规模重构。</p>"
  },
  "_id": "articles/react-18-concurrent-features.md",
  "_raw": {
    "sourceFilePath": "articles/react-18-concurrent-features.md",
    "sourceFileName": "react-18-concurrent-features.md",
    "sourceFileDir": "articles",
    "contentType": "markdown",
    "flattenedPath": "articles/react-18-concurrent-features"
  },
  "type": "Article",
  "slug": "react-18-concurrent-features",
  "readingTime": {
    "text": "6 min read",
    "minutes": 5.1,
    "time": 306000,
    "words": 1020
  },
  "url": "/articles/react-18-concurrent-features"
}