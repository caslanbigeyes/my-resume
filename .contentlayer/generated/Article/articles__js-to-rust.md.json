{
  "title": "用 JavaScript 的视角学习 Rust 编程",
  "excerpt": "从 JavaScript 开发者的角度深入学习 Rust 编程语言，通过对比和实例帮助前端开发者快速掌握 Rust 的核心概念。",
  "publishedAt": "2024-10-10T00:00:00.000Z",
  "author": "hero",
  "category": "backend",
  "tags": [
    "rust",
    "javascript",
    "programming"
  ],
  "featured": true,
  "published": true,
  "image": "/images/articles/js-to-rust.jpg",
  "seoTitle": "JavaScript 开发者学习 Rust 编程完全指南",
  "seoDescription": "从 JavaScript 视角学习 Rust，掌握类型系统、生命周期、所有权等核心概念",
  "seoKeywords": [
    "Rust",
    "JavaScript",
    "编程语言",
    "类型系统",
    "生命周期"
  ],
  "body": {
    "raw": "\n# 用 JavaScript 的视角学习 Rust 编程\n\n## 前言\n\nRust 是近年来备受关注的系统编程语言，其核心特点包括：\n\n### Rust 的三大特性\n\n- **高性能** - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。\n- **可靠性** - Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。\n- **生产力** - Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息，还集成了一流的工具——包管理器和构建工具，智能地自动补全和类型检验的多编辑器支持，以及自动格式化代码等等。\n\n### 为什么前端开发者要学习 Rust？\n\n随着前端基建在不断 Rust 化（如 SWC、Turbopack 等工具），以及 Rust 在编译成 WebAssembly 后在浏览器端的广泛应用，现阶段前端开发人员掌握 Rust 知识变得越来越有价值。\n\n本文将基于 JavaScript 知识进行 Rust 对比学习，帮助前端开发者快速上手 Rust。\n\n## 类型系统对比\n\n### 基本类型对比\n\nJavaScript 是一种弱类型的解释型语言，而 Rust 是强类型的编译型语言，在类型系统上更接近于 TypeScript。\n\n#### JavaScript vs Rust 基本类型\n\n| JavaScript | Rust | 说明 |\n|------------|------|------|\n| `number` | `i32`, `f64`, `u32` 等 | Rust 有多种数字类型 |\n| `string` | `String`, `&str` | Rust 区分拥有所有权的字符串和字符串切片 |\n| `boolean` | `bool` | 基本相同 |\n| `undefined`/`null` | `Option<T>` | Rust 用 Option 处理可能为空的值 |\n\n#### Rust 数字类型详解\n\nRust 的数字类型根据位数、符号位、浮点数分为：\n- **整数类型**: `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\n- **浮点类型**: `f32`, `f64`\n- **其他**: `char`（单个字符）, `bool`（布尔值）\n\n#### 复合类型\n\nRust 还包含元组、数组等原始复合类型：\n- **元组**: 类似 TypeScript 中的元组概念\n- **数组**: 与 JavaScript 的 Array 不同，Rust 中的数组长度固定且类型统一\n\n### 结构体定义对比\n\n#### TypeScript 方式\n```typescript\ntype Person = {\n  firstName: string;\n  lastName: string;\n};\n\nconst person: Person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n};\n```\n\n#### Rust 方式\n```rust\nstruct Person {\n    first_name: String,\n    last_name: String,\n}\n\nlet mut person = Person {\n    first_name: String::from(\"John\"),\n    last_name: String::from(\"Doe\"),\n};\n```\n\n## 泛型系统\n\n### 函数泛型对比\n\n#### TypeScript 泛型函数\n```typescript\nfunction largest<T>(list: T[]): T {\n  let largest = list[0];\n  for (let item of list) {\n    if (item > largest) {\n      largest = item;\n    }\n  }\n  return largest;\n}\n\nconsole.log(largest([1, 2, 3, 4, 5])); // 5\nconsole.log(largest([\"a\", \"b\", \"c\"])); // \"c\"\n```\n\n#### Rust 泛型函数\n```rust\nfn largest<T: PartialOrd>(list: &[T]) -> &T {\n    let mut largest = &list[0];\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let numbers = vec![34, 50, 25, 100, 65];\n    let result = largest(&numbers);\n    println!(\"The largest number is {}\", result);\n}\n```\n\n### 结构体泛型\n\n#### TypeScript\n```typescript\ntype Point<T> = {\n  x: T;\n  y: T;\n};\n\nconst intPoint: Point<number> = { x: 5, y: 10 };\nconst floatPoint: Point<number> = { x: 1.0, y: 4.0 };\n```\n\n#### Rust\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n```\n\n## Traits（特质）系统\n\nTraits 类似于其他语言中的接口（interface），定义了某些类型支持的行为的共同功能。\n\n### 定义和实现 Trait\n\n```rust\n// 定义一个 trait\npub trait Summary {\n    fn summarize(&self) -> String;\n}\n\n// 为结构体实现 trait\nstruct NewsArticle {\n    headline: String,\n    location: String,\n    author: String,\n    content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n```\n\n### 与 TypeScript Interface 对比\n\n#### TypeScript Interface\n```typescript\ninterface Drawable {\n  draw(): void;\n}\n\nclass Circle implements Drawable {\n  draw() {\n    console.log(\"Drawing a circle\");\n  }\n}\n```\n\n#### Rust Trait\n```rust\ntrait Drawable {\n    fn draw(&self);\n}\n\nstruct Circle;\n\nimpl Drawable for Circle {\n    fn draw(&self) {\n        println!(\"Drawing a circle\");\n    }\n}\n```\n\n## 所有权系统\n\n这是 Rust 最独特的特性，JavaScript 开发者需要重点理解。\n\n### 所有权规则\n\n1. Rust 中的每一个值都有一个被称为其所有者（owner）的变量\n2. 值在任一时刻有且只有一个所有者\n3. 当所有者（变量）离开作用域，这个值将被丢弃\n\n### 与 JavaScript 的对比\n\n#### JavaScript（引用传递）\n```javascript\nfunction takeOwnership(obj) {\n  obj.name = \"Modified\";\n  return obj;\n}\n\nlet myObj = { name: \"Original\" };\nlet newObj = takeOwnership(myObj);\nconsole.log(myObj.name); // \"Modified\" - 原对象被修改\n```\n\n#### Rust（所有权转移）\n```rust\nfn take_ownership(s: String) -> String {\n    println!(\"{}\", s);\n    s // 返回所有权\n}\n\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = take_ownership(s1); // s1 的所有权转移给函数\n    // println!(\"{}\", s1); // 错误！s1 不再有效\n    println!(\"{}\", s2); // 正确，s2 拥有所有权\n}\n```\n\n### 借用（Borrowing）\n\n```rust\nfn calculate_length(s: &String) -> usize { // s 是对 String 的引用\n    s.len()\n} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，所以什么也不会发生\n\nfn main() {\n    let s1 = String::from(\"hello\");\n    let len = calculate_length(&s1); // 传递引用，不转移所有权\n    println!(\"The length of '{}' is {}.\", s1, len); // s1 仍然有效\n}\n```\n\n## 生命周期\n\n生命周期是 Rust 独有的概念，确保引用在需要的时间内有效。\n\n### 生命周期注解\n\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n    \n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is {}\", result);\n}\n```\n\n### 结构体中的生命周期\n\n```rust\nstruct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n```\n\n## 错误处理\n\n### JavaScript vs Rust 错误处理\n\n#### JavaScript（try-catch）\n```javascript\nasync function fetchData() {\n  try {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n```\n\n#### Rust（Result 类型）\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn open_file() -> Result<File, std::io::Error> {\n    match File::open(\"hello.txt\") {\n        Ok(file) => Ok(file),\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => {\n                println!(\"File not found!\");\n                Err(error)\n            }\n            other_error => Err(error),\n        },\n    }\n}\n```\n\n## 模块系统\n\n### JavaScript vs Rust 模块\n\n#### JavaScript ES6 模块\n```javascript\n// math.js\nexport function add(a, b) {\n  return a + b;\n}\n\nexport default function multiply(a, b) {\n  return a * b;\n}\n\n// main.js\nimport multiply, { add } from './math.js';\n```\n\n#### Rust 模块\n```rust\n// lib.rs 或 main.rs\nmod math {\n    pub fn add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n    \n    pub fn multiply(a: i32, b: i32) -> i32 {\n        a * b\n    }\n}\n\nuse math::{add, multiply};\n\nfn main() {\n    println!(\"2 + 3 = {}\", add(2, 3));\n    println!(\"2 * 3 = {}\", multiply(2, 3));\n}\n```\n\n## 包管理和工具链\n\n### JavaScript vs Rust 工具链对比\n\n#### JavaScript 生态\n```bash\n# 包管理\nnpm install lodash\nyarn add lodash\npnpm add lodash\n\n# 运行和构建\nnpm run dev\nnpm run build\nnpm test\n\n# 项目初始化\nnpm init\nnpx create-react-app my-app\n```\n\n#### Rust 生态\n```bash\n# 包管理\ncargo add serde\ncargo remove serde\n\n# 运行和构建\ncargo run\ncargo build --release\ncargo test\n\n# 项目初始化\ncargo new my-project\ncargo init\n```\n\n### 依赖管理对比\n\n#### package.json (JavaScript)\n```json\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\",\n    \"axios\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^4.9.0\",\n    \"@types/node\": \"^18.0.0\"\n  }\n}\n```\n\n#### Cargo.toml (Rust)\n```toml\n[package]\nname = \"my-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\ntokio = { version = \"1.0\", features = [\"full\"] }\n\n[dev-dependencies]\ncriterion = \"0.4\"\n```\n\n## 异步编程对比\n\n### JavaScript Promise/async-await\n```javascript\nasync function fetchUserData(userId) {\n  try {\n    const response = await fetch(`/api/users/${userId}`);\n    const userData = await response.json();\n    return userData;\n  } catch (error) {\n    console.error('Failed to fetch user:', error);\n    throw error;\n  }\n}\n\n// 并发执行\nconst [user1, user2] = await Promise.all([\n  fetchUserData(1),\n  fetchUserData(2)\n]);\n```\n\n### Rust async/await\n```rust\nuse tokio;\nuse reqwest;\n\nasync fn fetch_user_data(user_id: u32) -> Result<User, reqwest::Error> {\n    let url = format!(\"https://api.example.com/users/{}\", user_id);\n    let response = reqwest::get(&url).await?;\n    let user: User = response.json().await?;\n    Ok(user)\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // 并发执行\n    let (user1, user2) = tokio::try_join!(\n        fetch_user_data(1),\n        fetch_user_data(2)\n    )?;\n\n    println!(\"User 1: {:?}\", user1);\n    println!(\"User 2: {:?}\", user2);\n    Ok(())\n}\n```\n\n## 总结\n\n从 JavaScript 到 Rust 的学习路径：\n\n1. **类型系统**: 从动态类型到静态强类型\n2. **内存管理**: 从垃圾回收到所有权系统\n3. **错误处理**: 从异常到 Result 类型\n4. **并发**: 从单线程事件循环到多线程安全\n5. **工具链**: 从 npm/yarn 到 Cargo\n6. **异步编程**: 从 Promise 到 Future\n\n### 学习建议\n\n1. **循序渐进**: 先掌握基本语法和类型系统\n2. **实践为主**: 通过小项目练习所有权和借用\n3. **对比学习**: 将 Rust 概念与 JavaScript 对应概念关联\n4. **工具熟悉**: 熟练使用 Cargo 和 Rust 开发工具\n5. **社区参与**: 积极参与 Rust 社区，阅读优秀的开源项目\n\nRust 虽然学习曲线陡峭，但其提供的内存安全、性能优势和现代化的工具链，使其成为系统编程和高性能应用的理想选择。对于前端开发者来说，掌握 Rust 不仅能够拓展技术栈，还能更好地理解和使用基于 Rust 构建的前端工具。\n\n## 推荐学习资源\n\n- [Rust 官方教程](https://doc.rust-lang.org/book/)\n- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)\n- [Rustlings 练习](https://github.com/rust-lang/rustlings)\n- [Rust 语言圣经](https://course.rs/)\n",
    "html": "<h1>用 JavaScript 的视角学习 Rust 编程</h1>\n<h2>前言</h2>\n<p>Rust 是近年来备受关注的系统编程语言，其核心特点包括：</p>\n<h3>Rust 的三大特性</h3>\n<ul>\n<li><strong>高性能</strong> - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。</li>\n<li><strong>可靠性</strong> - Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</li>\n<li><strong>生产力</strong> - Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息，还集成了一流的工具——包管理器和构建工具，智能地自动补全和类型检验的多编辑器支持，以及自动格式化代码等等。</li>\n</ul>\n<h3>为什么前端开发者要学习 Rust？</h3>\n<p>随着前端基建在不断 Rust 化（如 SWC、Turbopack 等工具），以及 Rust 在编译成 WebAssembly 后在浏览器端的广泛应用，现阶段前端开发人员掌握 Rust 知识变得越来越有价值。</p>\n<p>本文将基于 JavaScript 知识进行 Rust 对比学习，帮助前端开发者快速上手 Rust。</p>\n<h2>类型系统对比</h2>\n<h3>基本类型对比</h3>\n<p>JavaScript 是一种弱类型的解释型语言，而 Rust 是强类型的编译型语言，在类型系统上更接近于 TypeScript。</p>\n<h4>JavaScript vs Rust 基本类型</h4>\n<p>| JavaScript | Rust | 说明 |\n|------------|------|------|\n| <code>number</code> | <code>i32</code>, <code>f64</code>, <code>u32</code> 等 | Rust 有多种数字类型 |\n| <code>string</code> | <code>String</code>, <code>&#x26;str</code> | Rust 区分拥有所有权的字符串和字符串切片 |\n| <code>boolean</code> | <code>bool</code> | 基本相同 |\n| <code>undefined</code>/<code>null</code> | <code>Option&#x3C;T></code> | Rust 用 Option 处理可能为空的值 |</p>\n<h4>Rust 数字类型详解</h4>\n<p>Rust 的数字类型根据位数、符号位、浮点数分为：</p>\n<ul>\n<li><strong>整数类型</strong>: <code>i8</code>, <code>u8</code>, <code>i16</code>, <code>u16</code>, <code>i32</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>i128</code>, <code>u128</code>, <code>isize</code>, <code>usize</code></li>\n<li><strong>浮点类型</strong>: <code>f32</code>, <code>f64</code></li>\n<li><strong>其他</strong>: <code>char</code>（单个字符）, <code>bool</code>（布尔值）</li>\n</ul>\n<h4>复合类型</h4>\n<p>Rust 还包含元组、数组等原始复合类型：</p>\n<ul>\n<li><strong>元组</strong>: 类似 TypeScript 中的元组概念</li>\n<li><strong>数组</strong>: 与 JavaScript 的 Array 不同，Rust 中的数组长度固定且类型统一</li>\n</ul>\n<h3>结构体定义对比</h3>\n<h4>TypeScript 方式</h4>\n<pre><code class=\"language-typescript\">type Person = {\n  firstName: string;\n  lastName: string;\n};\n\nconst person: Person = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n};\n</code></pre>\n<h4>Rust 方式</h4>\n<pre><code class=\"language-rust\">struct Person {\n    first_name: String,\n    last_name: String,\n}\n\nlet mut person = Person {\n    first_name: String::from(\"John\"),\n    last_name: String::from(\"Doe\"),\n};\n</code></pre>\n<h2>泛型系统</h2>\n<h3>函数泛型对比</h3>\n<h4>TypeScript 泛型函数</h4>\n<pre><code class=\"language-typescript\">function largest&#x3C;T>(list: T[]): T {\n  let largest = list[0];\n  for (let item of list) {\n    if (item > largest) {\n      largest = item;\n    }\n  }\n  return largest;\n}\n\nconsole.log(largest([1, 2, 3, 4, 5])); // 5\nconsole.log(largest([\"a\", \"b\", \"c\"])); // \"c\"\n</code></pre>\n<h4>Rust 泛型函数</h4>\n<pre><code class=\"language-rust\">fn largest&#x3C;T: PartialOrd>(list: &#x26;[T]) -> &#x26;T {\n    let mut largest = &#x26;list[0];\n    for item in list {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let numbers = vec![34, 50, 25, 100, 65];\n    let result = largest(&#x26;numbers);\n    println!(\"The largest number is {}\", result);\n}\n</code></pre>\n<h3>结构体泛型</h3>\n<h4>TypeScript</h4>\n<pre><code class=\"language-typescript\">type Point&#x3C;T> = {\n  x: T;\n  y: T;\n};\n\nconst intPoint: Point&#x3C;number> = { x: 5, y: 10 };\nconst floatPoint: Point&#x3C;number> = { x: 1.0, y: 4.0 };\n</code></pre>\n<h4>Rust</h4>\n<pre><code class=\"language-rust\">struct Point&#x3C;T> {\n    x: T,\n    y: T,\n}\n\nimpl&#x3C;T> Point&#x3C;T> {\n    fn x(&#x26;self) -> &#x26;T {\n        &#x26;self.x\n    }\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n</code></pre>\n<h2>Traits（特质）系统</h2>\n<p>Traits 类似于其他语言中的接口（interface），定义了某些类型支持的行为的共同功能。</p>\n<h3>定义和实现 Trait</h3>\n<pre><code class=\"language-rust\">// 定义一个 trait\npub trait Summary {\n    fn summarize(&#x26;self) -> String;\n}\n\n// 为结构体实现 trait\nstruct NewsArticle {\n    headline: String,\n    location: String,\n    author: String,\n    content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&#x26;self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n</code></pre>\n<h3>与 TypeScript Interface 对比</h3>\n<h4>TypeScript Interface</h4>\n<pre><code class=\"language-typescript\">interface Drawable {\n  draw(): void;\n}\n\nclass Circle implements Drawable {\n  draw() {\n    console.log(\"Drawing a circle\");\n  }\n}\n</code></pre>\n<h4>Rust Trait</h4>\n<pre><code class=\"language-rust\">trait Drawable {\n    fn draw(&#x26;self);\n}\n\nstruct Circle;\n\nimpl Drawable for Circle {\n    fn draw(&#x26;self) {\n        println!(\"Drawing a circle\");\n    }\n}\n</code></pre>\n<h2>所有权系统</h2>\n<p>这是 Rust 最独特的特性，JavaScript 开发者需要重点理解。</p>\n<h3>所有权规则</h3>\n<ol>\n<li>Rust 中的每一个值都有一个被称为其所有者（owner）的变量</li>\n<li>值在任一时刻有且只有一个所有者</li>\n<li>当所有者（变量）离开作用域，这个值将被丢弃</li>\n</ol>\n<h3>与 JavaScript 的对比</h3>\n<h4>JavaScript（引用传递）</h4>\n<pre><code class=\"language-javascript\">function takeOwnership(obj) {\n  obj.name = \"Modified\";\n  return obj;\n}\n\nlet myObj = { name: \"Original\" };\nlet newObj = takeOwnership(myObj);\nconsole.log(myObj.name); // \"Modified\" - 原对象被修改\n</code></pre>\n<h4>Rust（所有权转移）</h4>\n<pre><code class=\"language-rust\">fn take_ownership(s: String) -> String {\n    println!(\"{}\", s);\n    s // 返回所有权\n}\n\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = take_ownership(s1); // s1 的所有权转移给函数\n    // println!(\"{}\", s1); // 错误！s1 不再有效\n    println!(\"{}\", s2); // 正确，s2 拥有所有权\n}\n</code></pre>\n<h3>借用（Borrowing）</h3>\n<pre><code class=\"language-rust\">fn calculate_length(s: &#x26;String) -> usize { // s 是对 String 的引用\n    s.len()\n} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，所以什么也不会发生\n\nfn main() {\n    let s1 = String::from(\"hello\");\n    let len = calculate_length(&#x26;s1); // 传递引用，不转移所有权\n    println!(\"The length of '{}' is {}.\", s1, len); // s1 仍然有效\n}\n</code></pre>\n<h2>生命周期</h2>\n<p>生命周期是 Rust 独有的概念，确保引用在需要的时间内有效。</p>\n<h3>生命周期注解</h3>\n<pre><code class=\"language-rust\">fn longest&#x3C;'a>(x: &#x26;'a str, y: &#x26;'a str) -> &#x26;'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n    \n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is {}\", result);\n}\n</code></pre>\n<h3>结构体中的生命周期</h3>\n<pre><code class=\"language-rust\">struct ImportantExcerpt&#x3C;'a> {\n    part: &#x26;'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n</code></pre>\n<h2>错误处理</h2>\n<h3>JavaScript vs Rust 错误处理</h3>\n<h4>JavaScript（try-catch）</h4>\n<pre><code class=\"language-javascript\">async function fetchData() {\n  try {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n</code></pre>\n<h4>Rust（Result 类型）</h4>\n<pre><code class=\"language-rust\">use std::fs::File;\nuse std::io::ErrorKind;\n\nfn open_file() -> Result&#x3C;File, std::io::Error> {\n    match File::open(\"hello.txt\") {\n        Ok(file) => Ok(file),\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => {\n                println!(\"File not found!\");\n                Err(error)\n            }\n            other_error => Err(error),\n        },\n    }\n}\n</code></pre>\n<h2>模块系统</h2>\n<h3>JavaScript vs Rust 模块</h3>\n<h4>JavaScript ES6 模块</h4>\n<pre><code class=\"language-javascript\">// math.js\nexport function add(a, b) {\n  return a + b;\n}\n\nexport default function multiply(a, b) {\n  return a * b;\n}\n\n// main.js\nimport multiply, { add } from './math.js';\n</code></pre>\n<h4>Rust 模块</h4>\n<pre><code class=\"language-rust\">// lib.rs 或 main.rs\nmod math {\n    pub fn add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n    \n    pub fn multiply(a: i32, b: i32) -> i32 {\n        a * b\n    }\n}\n\nuse math::{add, multiply};\n\nfn main() {\n    println!(\"2 + 3 = {}\", add(2, 3));\n    println!(\"2 * 3 = {}\", multiply(2, 3));\n}\n</code></pre>\n<h2>包管理和工具链</h2>\n<h3>JavaScript vs Rust 工具链对比</h3>\n<h4>JavaScript 生态</h4>\n<pre><code class=\"language-bash\"># 包管理\nnpm install lodash\nyarn add lodash\npnpm add lodash\n\n# 运行和构建\nnpm run dev\nnpm run build\nnpm test\n\n# 项目初始化\nnpm init\nnpx create-react-app my-app\n</code></pre>\n<h4>Rust 生态</h4>\n<pre><code class=\"language-bash\"># 包管理\ncargo add serde\ncargo remove serde\n\n# 运行和构建\ncargo run\ncargo build --release\ncargo test\n\n# 项目初始化\ncargo new my-project\ncargo init\n</code></pre>\n<h3>依赖管理对比</h3>\n<h4>package.json (JavaScript)</h4>\n<pre><code class=\"language-json\">{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\",\n    \"axios\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^4.9.0\",\n    \"@types/node\": \"^18.0.0\"\n  }\n}\n</code></pre>\n<h4>Cargo.toml (Rust)</h4>\n<pre><code class=\"language-toml\">[package]\nname = \"my-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\ntokio = { version = \"1.0\", features = [\"full\"] }\n\n[dev-dependencies]\ncriterion = \"0.4\"\n</code></pre>\n<h2>异步编程对比</h2>\n<h3>JavaScript Promise/async-await</h3>\n<pre><code class=\"language-javascript\">async function fetchUserData(userId) {\n  try {\n    const response = await fetch(`/api/users/${userId}`);\n    const userData = await response.json();\n    return userData;\n  } catch (error) {\n    console.error('Failed to fetch user:', error);\n    throw error;\n  }\n}\n\n// 并发执行\nconst [user1, user2] = await Promise.all([\n  fetchUserData(1),\n  fetchUserData(2)\n]);\n</code></pre>\n<h3>Rust async/await</h3>\n<pre><code class=\"language-rust\">use tokio;\nuse reqwest;\n\nasync fn fetch_user_data(user_id: u32) -> Result&#x3C;User, reqwest::Error> {\n    let url = format!(\"https://api.example.com/users/{}\", user_id);\n    let response = reqwest::get(&#x26;url).await?;\n    let user: User = response.json().await?;\n    Ok(user)\n}\n\n#[tokio::main]\nasync fn main() -> Result&#x3C;(), Box&#x3C;dyn std::error::Error>> {\n    // 并发执行\n    let (user1, user2) = tokio::try_join!(\n        fetch_user_data(1),\n        fetch_user_data(2)\n    )?;\n\n    println!(\"User 1: {:?}\", user1);\n    println!(\"User 2: {:?}\", user2);\n    Ok(())\n}\n</code></pre>\n<h2>总结</h2>\n<p>从 JavaScript 到 Rust 的学习路径：</p>\n<ol>\n<li><strong>类型系统</strong>: 从动态类型到静态强类型</li>\n<li><strong>内存管理</strong>: 从垃圾回收到所有权系统</li>\n<li><strong>错误处理</strong>: 从异常到 Result 类型</li>\n<li><strong>并发</strong>: 从单线程事件循环到多线程安全</li>\n<li><strong>工具链</strong>: 从 npm/yarn 到 Cargo</li>\n<li><strong>异步编程</strong>: 从 Promise 到 Future</li>\n</ol>\n<h3>学习建议</h3>\n<ol>\n<li><strong>循序渐进</strong>: 先掌握基本语法和类型系统</li>\n<li><strong>实践为主</strong>: 通过小项目练习所有权和借用</li>\n<li><strong>对比学习</strong>: 将 Rust 概念与 JavaScript 对应概念关联</li>\n<li><strong>工具熟悉</strong>: 熟练使用 Cargo 和 Rust 开发工具</li>\n<li><strong>社区参与</strong>: 积极参与 Rust 社区，阅读优秀的开源项目</li>\n</ol>\n<p>Rust 虽然学习曲线陡峭，但其提供的内存安全、性能优势和现代化的工具链，使其成为系统编程和高性能应用的理想选择。对于前端开发者来说，掌握 Rust 不仅能够拓展技术栈，还能更好地理解和使用基于 Rust 构建的前端工具。</p>\n<h2>推荐学习资源</h2>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/book/\">Rust 官方教程</a></li>\n<li><a href=\"https://doc.rust-lang.org/rust-by-example/\">Rust by Example</a></li>\n<li><a href=\"https://github.com/rust-lang/rustlings\">Rustlings 练习</a></li>\n<li><a href=\"https://course.rs/\">Rust 语言圣经</a></li>\n</ul>"
  },
  "_id": "articles/js-to-rust.md",
  "_raw": {
    "sourceFilePath": "articles/js-to-rust.md",
    "sourceFileName": "js-to-rust.md",
    "sourceFileDir": "articles",
    "contentType": "markdown",
    "flattenedPath": "articles/js-to-rust"
  },
  "type": "Article",
  "slug": "js-to-rust",
  "readingTime": {
    "text": "11 min read",
    "minutes": 10.925,
    "time": 655500,
    "words": 2185
  },
  "url": "/articles/js-to-rust"
}